diff -u -r -N -b GCO/block.h GCO-v3.0.src-patched/block.h
--- GCO/block.h	2012-11-15 17:28:04.000000000 +0100
+++ GCO-v3.0.src-patched/block.h	2013-04-29 10:02:09.000000000 +0200
@@ -87,8 +87,8 @@
 	deallocated only when the destructor is called.
 */
 
-#ifndef __BLOCK_H__
-#define __BLOCK_H__
+#ifndef __GCO_BLOCK_H__
+#define __GCO_BLOCK_H__
 
 #include <stdlib.h>
 
@@ -96,6 +96,8 @@
 /***********************************************************************/
 /***********************************************************************/
 
+namespace gcoLib {
+
 template <class Type> class Block
 {
 public:
@@ -103,7 +105,7 @@
 	   (optionally) the pointer to the function which
 	   will be called if allocation failed; the message
 	   passed to this function is "Not enough memory!" */
-	Block(int size, void (*err_function)(char *) = NULL) { first = last = NULL; block_size = size; error_function = err_function; }
+	Block(int size, void (*err_function)(const char *) = NULL) { first = last = NULL; block_size = size; error_function = err_function; }
 
 	/* Destructor. Deallocates all items added so far */
 	~Block() { while (first) { block *next = first -> next; delete first; first = next; } }
@@ -192,7 +194,7 @@
 	block	*scan_current_block;
 	Type	*scan_current_data;
 
-	void	(*error_function)(char *);
+	void	(*error_function)(const char *);
 };
 
 /***********************************************************************/
@@ -206,7 +208,7 @@
 	   (optionally) the pointer to the function which
 	   will be called if allocation failed; the message
 	   passed to this function is "Not enough memory!" */
-	DBlock(int size, void (*err_function)(char *) = NULL) { first = NULL; first_free = NULL; block_size = size; error_function = err_function; }
+	DBlock(int size, void (*err_function)(const char *) = NULL) { first = NULL; first_free = NULL; block_size = size; error_function = err_function; }
 
 	/* Destructor. Deallocates all items added so far */
 	~DBlock() { while (first) { block *next = first -> next; delete first; first = next; } }
@@ -260,9 +262,10 @@
 	block		*first;
 	block_item	*first_free;
 
-	void	(*error_function)(char *);
+	void	(*error_function)(const char *);
 };
 
+} // namespace gcoLib
 
 #endif
 
diff -u -r -N -b GCO/energy.h GCO-v3.0.src-patched/energy.h
--- GCO/energy.h	2012-11-15 17:28:04.000000000 +0100
+++ GCO-v3.0.src-patched/energy.h	2013-04-29 10:02:09.000000000 +0200
@@ -70,12 +70,14 @@
 	///////////////////////////////////////////////////
 */
 
-#ifndef __ENERGY_H__
-#define __ENERGY_H__
+#ifndef __GCO_ENERGY_H__
+#define __GCO_ENERGY_H__
 
 #include <assert.h>
 #include "graph.h"
 
+namespace gcoLib {
+
 template <typename captype, typename tcaptype, typename flowtype> class Energy: public Graph<captype,tcaptype,flowtype>
 {
 	typedef Graph<captype,tcaptype,flowtype> GraphT;
@@ -96,7 +98,7 @@
 	   function which will be called if an error occurs;
 	   an error message is passed to this function. If this
 	   argument is omitted, exit(1) will be called. */
-	Energy(int var_num_max, int edge_num_max, void (*err_function)(char *) = NULL);
+	Energy(int var_num_max, int edge_num_max, void (*err_function)(const char *) = NULL);
 
 	/* Destructor */
 	~Energy();
@@ -160,7 +162,7 @@
 	/* internal variables and functions */
 
 	TotalValue	Econst;
-	void		(*error_function)(char *);	/* this function is called if a error occurs,
+	void		(*error_function)(const char *);	/* this function is called if a error occurs,
 											with a corresponding error message
 											(or exit(1) is called if it's NULL) */
 };
@@ -184,7 +186,7 @@
 /***********************************************************************/
 
 template <typename captype, typename tcaptype, typename flowtype> 
-inline Energy<captype,tcaptype,flowtype>::Energy(int var_num_max, int edge_num_max, void (*err_function)(char *)) : Graph<captype,tcaptype,flowtype>(var_num_max, edge_num_max, err_function)
+inline Energy<captype,tcaptype,flowtype>::Energy(int var_num_max, int edge_num_max, void (*err_function)(const char *)) : Graph<captype,tcaptype,flowtype>(var_num_max, edge_num_max, err_function)
 {
 	Econst = 0;
 	error_function = err_function;
@@ -327,4 +329,6 @@
 template <typename captype, typename tcaptype, typename flowtype> 
 inline int Energy<captype,tcaptype,flowtype>::get_var(Var x) { return (int) what_segment(x); }
 
+} // namespace gcoLib
+
 #endif
diff -u -r -N -b GCO/example.cpp GCO-v3.0.src-patched/example.cpp
--- GCO/example.cpp	2012-11-15 17:28:04.000000000 +0100
+++ GCO-v3.0.src-patched/example.cpp	2013-04-29 10:02:09.000000000 +0200
@@ -25,8 +25,12 @@
 #include <math.h>
 #include <string.h>
 #include <time.h>
+
+#define GCOENERGYVALUE int
+#define GCOLABELVALUE int
 #include "GCoptimization.h"
 
+using namespace gcoLib;
 
 struct ForDataFn{
 	int numLab;
@@ -92,7 +96,7 @@
 
 		delete gc;
 	}
-	catch (GCException e){
+   catch (GCException& e){
 		e.Report();
 	}
 
@@ -140,7 +144,7 @@
 
 		delete gc;
 	}
-	catch (GCException e){
+   catch (GCException& e){
 		e.Report();
 	}
 
@@ -194,7 +198,7 @@
 
 		delete gc;
 	}
-	catch (GCException e){
+   catch (GCException& e){
 		e.Report();
 	}
 
@@ -253,7 +257,7 @@
 
 		delete gc;
 	}
-	catch (GCException e){
+   catch (GCException& e){
 		e.Report();
 	}
 
@@ -317,7 +321,7 @@
 
 		delete gc;
 	}
-	catch (GCException e){
+   catch (GCException& e){
 		e.Report();
 	}
 
@@ -386,7 +390,7 @@
 
 		delete gc;
 	}
-	catch (GCException e){
+   catch (GCException& e){
 		e.Report();
 	}
 
diff -u -r -N -b GCO/GCoptimization.cpp GCO-v3.0.src-patched/GCoptimization.cpp
--- GCO/GCoptimization.cpp	2012-11-15 17:28:04.000000000 +0100
+++ GCO-v3.0.src-patched/GCoptimization.cpp	2013-04-29 10:02:09.000000000 +0200
@@ -8,6 +8,8 @@
 #include <vector>
 #include <algorithm>
 
+namespace gcoLib {
+
 // will leave this one just for the laughs :)
 //#define olga_assert(expr) assert(!(expr))
 
@@ -1227,7 +1229,7 @@
 		// and compute the smooth costs between variables.
 		EnergyT e(size+m_labelcostCount, // poor guess at number of pairwise terms needed :(
 				 m_numNeighborsTotal+(m_labelcostCount?size+m_labelcostCount : 0),
-				 (void(*)(char*))handleError);
+				 (void(*)(const char*))handleError);
 		e.add_variable(size);
 		m_beforeExpansionEnergy = 0;
 		if ( m_setupDataCostsExpansion   ) (this->*m_setupDataCostsExpansion  )(size,alpha_label,&e,activeSites);
@@ -1361,7 +1363,7 @@
 
 		// Create binary variables for each remaining site, add the data costs,
 		// and compute the smooth costs between variables.
-		EnergyT e(size,m_numNeighborsTotal,(void(*)(char*))handleError);
+		EnergyT e(size,m_numNeighborsTotal,(void(*)(const char*))handleError);
 		e.add_variable(size);
 		if ( m_setupDataCostsSwap   ) (this->*m_setupDataCostsSwap  )(size,alpha_label,beta_label,&e,activeSites);
 		if ( m_setupSmoothCostsSwap ) (this->*m_setupSmoothCostsSwap)(size,alpha_label,beta_label,&e,activeSites);
@@ -1871,3 +1873,4 @@
 	return count;
 }
 
+} // namespace gcoLib
diff -u -r -N -b GCO/GCoptimization.h GCO-v3.0.src-patched/GCoptimization.h
--- GCO/GCoptimization.h	2012-11-15 17:28:24.000000000 +0100
+++ GCO-v3.0.src-patched/GCoptimization.h	2013-04-29 10:04:19.000000000 +0200
@@ -113,6 +113,7 @@
 /////////////////////////////////////////////////////////////////////
 // Utility functions, classes, and macros
 /////////////////////////////////////////////////////////////////////
+namespace gcoLib {
 
 class GCException {
 public:
@@ -124,7 +125,9 @@
 #ifdef _WIN32
 typedef __int64 gcoclock_t;
 #else
+} // namespace gcoLib
 #include <ctime>
+namespace gcoLib {
 typedef clock_t gcoclock_t;
 #endif
 extern "C" gcoclock_t gcoclock(); // fairly high-resolution timer... better than clock() when available
@@ -152,14 +155,14 @@
 {
 public: 
 #ifdef GCO_ENERGYTYPE32
-	typedef int EnergyType;        // 32-bit energy total
+	typedef GCOENERGYVALUE EnergyType;        // 32-bit energy total
 #else
-	typedef long long EnergyType;  // 64-bit energy total
+	typedef GCOENERGYVALUE EnergyType;  // 64-bit energy total
 #endif
-	typedef int EnergyTermType;    // 32-bit energy terms
+	typedef GCOENERGYVALUE EnergyTermType;    // 32-bit energy terms
 	typedef Energy<EnergyTermType,EnergyTermType,EnergyType> EnergyT;
 	typedef EnergyT::Var VarID;
-	typedef int LabelID;                     // Type for labels
+	typedef GCOLABELVALUE LabelID;                     // Type for labels
 	typedef VarID SiteID;                    // Type for sites
 	typedef EnergyTermType (*SmoothCostFn)(SiteID s1, SiteID s2, LabelID l1, LabelID l2);
 	typedef EnergyTermType (*DataCostFn)(SiteID s, LabelID l);
@@ -613,4 +616,6 @@
 	return m_labeling[site];
 }
 
+} // namespace gcoLib
+
 #endif
diff -u -r -N -b GCO/graph.cpp GCO-v3.0.src-patched/graph.cpp
--- GCO/graph.cpp	2012-11-15 17:28:04.000000000 +0100
+++ GCO-v3.0.src-patched/graph.cpp	2013-04-29 10:02:09.000000000 +0200
@@ -6,9 +6,10 @@
 #include <string.h>
 #include "graph.h"
 
+namespace gcoLib {
 
 template <typename captype, typename tcaptype, typename flowtype> 
-	Graph<captype, tcaptype, flowtype>::Graph(int node_num_max, int edge_num_max, void (*err_function)(char *))
+	Graph<captype, tcaptype, flowtype>::Graph(int node_num_max, int edge_num_max, void (*err_function)(const char *))
 	: node_num(0),
 	  nodeptr_block(NULL),
 	  error_function(err_function)
@@ -112,3 +113,4 @@
 	}
 }
 
+} // namespace gcoLib
diff -u -r -N -b GCO/graph.h GCO-v3.0.src-patched/graph.h
--- GCO/graph.h	2012-11-15 17:28:04.000000000 +0100
+++ GCO-v3.0.src-patched/graph.h	2013-04-29 10:02:09.000000000 +0200
@@ -36,8 +36,8 @@
 	For description, license, example usage see README.TXT.
 */
 
-#ifndef __GRAPH_H__
-#define __GRAPH_H__
+#ifndef __GCO_GRAPH_H__
+#define __GCO_GRAPH_H__
 
 #include <string.h>
 #include "block.h"
@@ -45,7 +45,7 @@
 #include <assert.h>
 // NOTE: in UNIX you need to use -DNDEBUG preprocessor option to supress assert's!!!
 
-
+namespace gcoLib {
 
 // captype: type of edge capacities (excluding t-links)
 // tcaptype: type of t-links (edges between nodes and terminals)
@@ -80,7 +80,7 @@
 	// Also, temporarily the amount of allocated memory would be more than twice than needed.
 	// Similarly for edges.
 	// If you wish to avoid this overhead, you can download version 2.2, where nodes and edges are stored in blocks.
-	Graph(int node_num_max, int edge_num_max, void (*err_function)(char *) = NULL);
+	Graph(int node_num_max, int edge_num_max, void (*err_function)(const char *) = NULL);
 
 	// Destructor
 	~Graph();
@@ -291,7 +291,7 @@
 		node    	*ptr;
 		nodeptr		*next;
 	};
-	static const int NODEPTR_BLOCK_SIZE = 128;
+	static const int GCO_NODEPTR_BLOCK_SIZE = 128;
 
 	node				*nodes, *node_last, *node_max; // node_last = nodes+node_num, node_max = nodes+node_num_max;
 	arc					*arcs, *arc_last, *arc_max; // arc_last = arcs+2*edge_num, arc_max = arcs+2*edge_num_max;
@@ -300,7 +300,7 @@
 
 	DBlock<nodeptr>		*nodeptr_block;
 
-	void	(*error_function)(char *);	// this function is called if a error occurs,
+	void	(*error_function)(const char *);	// this function is called if a error occurs,
 										// with a corresponding error message
 										// (or exit(1) is called if it's NULL)
 
@@ -502,5 +502,6 @@
 	i->is_marked = 1;
 }
 
+} // namespace gcoLib
 
 #endif
diff -u -r -N -b GCO/LinkedBlockList.cpp GCO-v3.0.src-patched/LinkedBlockList.cpp
--- GCO/LinkedBlockList.cpp	2012-11-15 17:28:04.000000000 +0100
+++ GCO-v3.0.src-patched/LinkedBlockList.cpp	2013-04-29 10:02:09.000000000 +0200
@@ -2,6 +2,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 
+namespace gcoLib {
+
 /*********************************************************************/
 
 void LinkedBlockList::addFront(ListType item) {
@@ -65,3 +67,4 @@
 
 /*********************************************************************/
 
+} // namespace gcoLib
diff -u -r -N -b GCO/LinkedBlockList.h GCO-v3.0.src-patched/LinkedBlockList.h
--- GCO/LinkedBlockList.h	2012-11-15 17:28:04.000000000 +0100
+++ GCO-v3.0.src-patched/LinkedBlockList.h	2013-04-29 10:02:09.000000000 +0200
@@ -6,8 +6,10 @@
 // For other graphs, it should be set to the average expected number of neighbors
 // Data in linked list for the neighborhood system is allocated in blocks of size GCLL_BLOCK_SIZE 
 
-#ifndef __LINKEDBLOCKLIST_H__
-#define __LINKEDBLOCKLIST_H__
+#ifndef __GCO_LINKEDBLOCKLIST_H__
+#define __GCO_LINKEDBLOCKLIST_H__
+
+namespace gcoLib {
 
 #define GCLL_BLOCK_SIZE 4  
 // GCLL_BLOCKSIZE should "fit" into the type BlockType. That is 
@@ -46,5 +48,7 @@
 	LLBlock *m_cursor;
 };
 
+} // namespace gcoLib
+
 #endif
 
diff -u -r -N -b GCO/maxflow.cpp GCO-v3.0.src-patched/maxflow.cpp
--- GCO/maxflow.cpp	2012-11-15 17:28:04.000000000 +0100
+++ GCO-v3.0.src-patched/maxflow.cpp	2013-04-29 10:02:09.000000000 +0200
@@ -4,15 +4,16 @@
 #include <stdio.h>
 #include "graph.h"
 
+namespace gcoLib {
 
 /*
 	special constants for node->parent
 */
-#define TERMINAL ( (arc *) 1 )		/* to terminal */
-#define ORPHAN   ( (arc *) 2 )		/* orphan */
+#define GCO_TERMINAL ( (arc *) 1 )		/* to terminal */
+#define GCO_ORPHAN   ( (arc *) 2 )		/* orphan */
 
 
-#define INFINITE_D ((int)(((unsigned)-1)/2))		/* infinite distance to the terminal */
+#define GCO_INFINITE_D ((int)(((unsigned)-1)/2))		/* infinite distance to the terminal */
 
 /***********************************************************************/
 
@@ -80,7 +81,7 @@
 	inline void Graph<captype,tcaptype,flowtype>::set_orphan_front(node *i)
 {
 	nodeptr *np;
-	i -> parent = ORPHAN;
+	i -> parent = GCO_ORPHAN;
 	np = nodeptr_block -> New();
 	np -> ptr = i;
 	np -> next = orphan_first;
@@ -91,7 +92,7 @@
 	inline void Graph<captype,tcaptype,flowtype>::set_orphan_rear(node *i)
 {
 	nodeptr *np;
-	i -> parent = ORPHAN;
+	i -> parent = GCO_ORPHAN;
 	np = nodeptr_block -> New();
 	np -> ptr = i;
 	if (orphan_last) orphan_last -> next = np;
@@ -136,7 +137,7 @@
 		{
 			/* i is connected to the source */
 			i -> is_sink = 0;
-			i -> parent = TERMINAL;
+			i -> parent = GCO_TERMINAL;
 			set_active(i);
 			i -> DIST = 1;
 		}
@@ -144,7 +145,7 @@
 		{
 			/* i is connected to the sink */
 			i -> is_sink = 1;
-			i -> parent = TERMINAL;
+			i -> parent = GCO_TERMINAL;
 			set_active(i);
 			i -> DIST = 1;
 		}
@@ -218,7 +219,7 @@
 				add_to_changed_list(i);
 			}
 		}
-		i->parent = TERMINAL;
+		i->parent = GCO_TERMINAL;
 		i -> TS = TIME;
 		i -> DIST = 1;
 	}
@@ -254,7 +255,7 @@
 	for (i=middle_arc->sister->head; ; i=a->head)
 	{
 		a = i -> parent;
-		if (a == TERMINAL) break;
+		if (a == GCO_TERMINAL) break;
 		if (bottleneck > a->sister->r_cap) bottleneck = a -> sister -> r_cap;
 	}
 	if (bottleneck > i->tr_cap) bottleneck = i -> tr_cap;
@@ -262,7 +263,7 @@
 	for (i=middle_arc->head; ; i=a->head)
 	{
 		a = i -> parent;
-		if (a == TERMINAL) break;
+		if (a == GCO_TERMINAL) break;
 		if (bottleneck > a->r_cap) bottleneck = a -> r_cap;
 	}
 	if (bottleneck > - i->tr_cap) bottleneck = - i -> tr_cap;
@@ -275,7 +276,7 @@
 	for (i=middle_arc->sister->head; ; i=a->head)
 	{
 		a = i -> parent;
-		if (a == TERMINAL) break;
+		if (a == GCO_TERMINAL) break;
 		a -> r_cap += bottleneck;
 		a -> sister -> r_cap -= bottleneck;
 		if (!a->sister->r_cap)
@@ -292,7 +293,7 @@
 	for (i=middle_arc->head; ; i=a->head)
 	{
 		a = i -> parent;
-		if (a == TERMINAL) break;
+		if (a == GCO_TERMINAL) break;
 		a -> sister -> r_cap += bottleneck;
 		a -> r_cap -= bottleneck;
 		if (!a->r_cap)
@@ -317,7 +318,7 @@
 {
 	node *j;
 	arc *a0, *a0_min = NULL, *a;
-	int d, d_min = INFINITE_D;
+	int d, d_min = GCO_INFINITE_D;
 
 	/* trying to find a new parent */
 	for (a0=i->first; a0; a0=a0->next)
@@ -337,16 +338,16 @@
 				}
 				a = j -> parent;
 				d ++;
-				if (a==TERMINAL)
+				if (a==GCO_TERMINAL)
 				{
 					j -> TS = TIME;
 					j -> DIST = 1;
 					break;
 				}
-				if (a==ORPHAN) { d = INFINITE_D; break; }
+				if (a==GCO_ORPHAN) { d = GCO_INFINITE_D; break; }
 				j = a -> head;
 			}
-			if (d<INFINITE_D) /* j originates from the source - done */
+			if (d<GCO_INFINITE_D) /* j originates from the source - done */
 			{
 				if (d<d_min)
 				{
@@ -380,7 +381,7 @@
 			if (!j->is_sink && (a=j->parent))
 			{
 				if (a0->sister->r_cap) set_active(j);
-				if (a!=TERMINAL && a!=ORPHAN && a->head==i)
+				if (a!=GCO_TERMINAL && a!=GCO_ORPHAN && a->head==i)
 				{
 					set_orphan_rear(j); // add j to the end of the adoption list
 				}
@@ -394,7 +395,7 @@
 {
 	node *j;
 	arc *a0, *a0_min = NULL, *a;
-	int d, d_min = INFINITE_D;
+	int d, d_min = GCO_INFINITE_D;
 
 	/* trying to find a new parent */
 	for (a0=i->first; a0; a0=a0->next)
@@ -414,16 +415,16 @@
 				}
 				a = j -> parent;
 				d ++;
-				if (a==TERMINAL)
+				if (a==GCO_TERMINAL)
 				{
 					j -> TS = TIME;
 					j -> DIST = 1;
 					break;
 				}
-				if (a==ORPHAN) { d = INFINITE_D; break; }
+				if (a==GCO_ORPHAN) { d = GCO_INFINITE_D; break; }
 				j = a -> head;
 			}
-			if (d<INFINITE_D) /* j originates from the sink - done */
+			if (d<GCO_INFINITE_D) /* j originates from the sink - done */
 			{
 				if (d<d_min)
 				{
@@ -457,7 +458,7 @@
 			if (j->is_sink && (a=j->parent))
 			{
 				if (a0->r_cap) set_active(j);
-				if (a!=TERMINAL && a!=ORPHAN && a->head==i)
+				if (a!=GCO_TERMINAL && a!=GCO_ORPHAN && a->head==i)
 				{
 					set_orphan_rear(j); // add j to the end of the adoption list
 				}
@@ -477,7 +478,7 @@
 
 	if (!nodeptr_block)
 	{
-		nodeptr_block = new DBlock<nodeptr>(NODEPTR_BLOCK_SIZE, error_function);
+		nodeptr_block = new DBlock<nodeptr>(GCO_NODEPTR_BLOCK_SIZE, error_function);
 	}
 
 	changed_list = _changed_list;
@@ -640,8 +641,8 @@
 	{
 		// test whether all edges in seach trees are non-saturated
 		if (i->parent == NULL) {}
-		else if (i->parent == ORPHAN) {}
-		else if (i->parent == TERMINAL)
+		else if (i->parent == GCO_ORPHAN) {}
+		else if (i->parent == GCO_TERMINAL)
 		{
 			if (!i->is_sink) assert(i->tr_cap > 0);
 			else             assert(i->tr_cap < 0);
@@ -673,7 +674,7 @@
 			}
 		}
 		// test marking invariants
-		if (i->parent && i->parent!=ORPHAN && i->parent!=TERMINAL)
+		if (i->parent && i->parent!=GCO_ORPHAN && i->parent!=GCO_TERMINAL)
 		{
 			assert(i->TS <= i->parent->head->TS);
 			if (i->TS == i->parent->head->TS) assert(i->DIST > i->parent->head->DIST);
@@ -708,7 +709,7 @@
 	for (i=nodes; i<node_last; i++)
 	{
 		if (i->first) i->first  = (arc*)((char*)arcs + (((char*)i->first)  - ((char*)g0->arcs)));
-		if (i->parent && i->parent!=TERMINAL && i->parent!=ORPHAN) i->parent = (arc*)((char*)arcs + (((char*)i->parent) - ((char*)g0->arcs)));
+		if (i->parent && i->parent!=GCO_TERMINAL && i->parent!=GCO_ORPHAN) i->parent = (arc*)((char*)arcs + (((char*)i->parent) - ((char*)g0->arcs)));
 		if (i->next) i->next   = (node*)((char*)nodes + (((char*)i->next) - ((char*)g0->nodes)));
 	}
 
@@ -731,3 +732,5 @@
 	queue_last[1] = (g0->queue_last[1]==NULL) ? NULL : (node*)((char*)nodes + (((char*)g0->queue_last[1]) - ((char*)g0->nodes)));
 	TIME = g0->TIME;
 }
+
+} // namespace gcoLib
