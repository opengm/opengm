

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>OpenGM Python Tutorial &mdash; vigranumpy beta0.91 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     'beta0.91',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="vigranumpy beta0.91 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="#">vigranumpy beta0.91 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="opengm-python-tutorial">
<h1><a class="toc-backref" href="#id13">OpenGM Python Tutorial</a><a class="headerlink" href="#opengm-python-tutorial" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#opengm-python-tutorial" id="id13">OpenGM Python Tutorial</a><ul>
<li><a class="reference internal" href="#introduction" id="id14">Introduction</a></li>
<li><a class="reference internal" href="#import-opengm" id="id15">Import Opengm</a></li>
<li><a class="reference internal" href="#construct-a-graphical-model" id="id16">Construct a Graphical Model</a><ul>
<li><a class="reference internal" href="#add-functions-to-a-graphical-model" id="id17">Add Functions to a Graphical Model</a></li>
<li><a class="reference internal" href="#add-factors-and-functions-to-a-graphical-model" id="id18">Add Factors and Functions to a Graphical Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#save-and-load-a-graphical-model" id="id19">Save and Load a Graphical Model</a></li>
<li><a class="reference internal" href="#infer-optimize-a-graphical-model" id="id20">Infer/Optimize a Graphical Model</a><ul>
<li><a class="reference internal" href="#belief-propagation-bp" id="id21">Belief propagation (Bp)</a></li>
<li><a class="reference internal" href="#treereweighted-belief-propagation-trbp" id="id22">Treereweighted Belief propagation (Trbp)</a></li>
<li><a class="reference internal" href="#icm" id="id23">ICM</a></li>
<li><a class="reference internal" href="#gibbs" id="id24">Gibbs</a></li>
<li><a class="reference internal" href="#astar" id="id25">AStar</a></li>
<li><a class="reference internal" href="#loc" id="id26">LOC</a></li>
<li><a class="reference internal" href="#lazy-flipper" id="id27">Lazy Flipper</a></li>
<li><a class="reference internal" href="#graph-cut" id="id28">Graph Cut</a></li>
<li><a class="reference internal" href="#alpha-beta-swap" id="id29">Alpha Beta Swap</a></li>
<li><a class="reference internal" href="#alpha-expansion" id="id30">Alpha Expansion</a></li>
<li><a class="reference internal" href="#cplex" id="id31">CPlex</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#opengm-python-examples" id="id32">OpenGM Python Examples</a><ul>
<li><a class="reference internal" href="#potts-model" id="id33">Potts Model</a></li>
<li><a class="reference internal" href="#markov-chain" id="id34">Markov Chain</a></li>
<li><a class="reference internal" href="#interpixel-boundary-segmentation" id="id35">Interpixel Boundary Segmentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#opengm-python-snippets" id="id36">OpenGM Python Snippets</a><ul>
<li><a class="reference internal" href="#inspect-a-graphical-model" id="id37">Inspect a Graphical Model</a></li>
<li><a class="reference internal" href="#iterate-over-a-factors-values" id="id38">Iterate over a Factors Values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#opengm-python-reference-documentation" id="id39">OpenGM Python Reference Documentation</a><ul>
<li><a class="reference internal" href="#id1" id="id40">opengm</a><ul>
<li><a class="reference internal" href="#graphicalmodel" id="id41">GraphicalModel</a></li>
<li><a class="reference internal" href="#factor" id="id42">Factor</a></li>
<li><a class="reference internal" href="#independentfactor" id="id43">IndependentFactor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#opengm-inference" id="id44">opengm.inference</a><ul>
<li><a class="reference internal" href="#id2" id="id45">AStar</a></li>
<li><a class="reference internal" href="#id3" id="id46">Belief Propagation (Bp)</a></li>
<li><a class="reference internal" href="#tree-reweighted-bp-trbp" id="id47">Tree Reweighted Bp (TrBp)</a></li>
<li><a class="reference internal" href="#dynamic-programming" id="id48">Dynamic Programming</a></li>
<li><a class="reference internal" href="#id4" id="id49">ICM</a></li>
<li><a class="reference internal" href="#lazy-flipper-lf" id="id50">Lazy Flipper (LF)</a></li>
<li><a class="reference internal" href="#id5" id="id51">LOC</a></li>
<li><a class="reference internal" href="#id6" id="id52">Gibbs</a></li>
<li><a class="reference internal" href="#grah-cut-gc" id="id53">Grah Cut (GC)</a></li>
<li><a class="reference internal" href="#id9" id="id54">Alpha-Beta Swap</a></li>
<li><a class="reference internal" href="#id11" id="id55">Alpha-Expansion</a></li>
<li><a class="reference internal" href="#bruteforce" id="id56">Bruteforce</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="toctree-wrapper compound">
<ul class="simple">
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id14">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://hci.iwr.uni-heidelberg.de/opengm2/">OpenGM</a>  is a C++ template library for discrete factor graph models and distributive operations on these models.
OpenGM Python exports the functionality of the C++ library OpenGM to Python.
It includes state-of-the-art optimization and inference algorithms beyond message passing.
OpenGM handles large models efficiently, since  functions that occur repeatedly need to be stored only once .
No restrictions are imposed on the factor graph or the operations of the model.
The graphical model data structure, inference algorithms and different encodings of functions interoperate through well-defined interfaces.
The binary OpenGM file format is based on the HDF5 standard and incorporates user extensions automatically.</p>
</div>
<div class="section" id="import-opengm">
<h2><a class="toc-backref" href="#id15">Import Opengm</a><a class="headerlink" href="#import-opengm" title="Permalink to this headline">¶</a></h2>
<p>To import opengm just type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">opengm</span>
</pre></div>
</div>
</div>
<div class="section" id="construct-a-graphical-model">
<h2><a class="toc-backref" href="#id16">Construct a Graphical Model</a><a class="headerlink" href="#construct-a-graphical-model" title="Permalink to this headline">¶</a></h2>
<p>A graphical model (gm) is always constructed from a sequence containing the
number of labels for all the variables.
The number of variables is given by the length of the sequence.
The type of the sequence can be a list or an 1d-numpy.ndarray</p>
<p>A gm can be constructed from a list in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">numberOfLabels</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">gm</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">(</span><span class="n">numberOfLabels</span><span class="p">)</span>
</pre></div>
</div>
<p>The result is a gm with 5 variables. All of them have two labels / states.
The operator of the gm is an Adder (+).
The operator can also be specified.
The following lines will construct two graphical models, one with an Adder(+) as operator, and one with a Multiplier(*) as operator.
This time a numpy.ndarray is used as number of labels sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">numberOfLabels</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
<span class="n">gm1</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">(</span><span class="n">numberOfLabels</span><span class="p">,</span><span class="n">operator</span><span class="o">=</span><span class="s">&#39;adder&#39;</span><span class="p">)</span>
<span class="n">gm2</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">(</span><span class="n">numberOfLabels</span><span class="p">,</span><span class="n">operator</span><span class="o">=</span><span class="s">&#39;multiplier&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The result will be two graphical models, each with 3 variables where each variable has four states.
The operator of gm1 is an Adder(+), the operator of gm2 is an Multiplier (*)</p>
<div class="section" id="add-functions-to-a-graphical-model">
<h3><a class="toc-backref" href="#id17">Add Functions to a Graphical Model</a><a class="headerlink" href="#add-functions-to-a-graphical-model" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="add-factors-and-functions-to-a-graphical-model">
<h3><a class="toc-backref" href="#id18">Add Factors and Functions to a Graphical Model</a><a class="headerlink" href="#add-factors-and-functions-to-a-graphical-model" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Variable Indices must always be sorted</p>
</div>
</div>
</div>
<div class="section" id="save-and-load-a-graphical-model">
<h2><a class="toc-backref" href="#id19">Save and Load a Graphical Model</a><a class="headerlink" href="#save-and-load-a-graphical-model" title="Permalink to this headline">¶</a></h2>
<p>Save a gm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">opengm</span><span class="o">.</span><span class="n">hdf5</span><span class="o">.</span><span class="n">saveGraphicalModel</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span><span class="s">&#39;path&#39;</span><span class="p">,</span><span class="s">&#39;dataset&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Load a gm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">opengm</span><span class="o">.</span><span class="n">hdf5</span><span class="o">.</span><span class="n">loadGraphicalModel</span><span class="p">(</span><span class="n">gm</span><span class="p">,</span><span class="s">&#39;path&#39;</span><span class="p">,</span><span class="s">&#39;dataset&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently only graphical models with which use only the explicit function can be loaded.
If the gm has been saved from Python only the explicit function  is used and this is not
a limitation.
If the gm has been saved from C++ this can be a limitation.
Within the next release of OpenGM Python this will be changed so that all default function types can
be loaded.</p>
</div>
</div>
<div class="section" id="infer-optimize-a-graphical-model">
<h2><a class="toc-backref" href="#id20">Infer/Optimize a Graphical Model</a><a class="headerlink" href="#infer-optimize-a-graphical-model" title="Permalink to this headline">¶</a></h2>
<p>Getting the inference object and the corresponding parameter object is the same
for all algorithms. The following algorithms are implemented within OpenGM Python</p>
<ul>
<li><p class="first">Belief propagation (<tt class="docutils literal"><span class="pre">'bp'</span></tt>) Semirings:  (min ,+), (max,+), (min,*), (max,*)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;bp&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Treereweighted Bp (<tt class="docutils literal"><span class="pre">'trbp'</span></tt>) Semirings:  (min ,+), (max,+), (min,*), (max,*)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;trbp&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">ICM (<tt class="docutils literal"><span class="pre">'icm'</span></tt>)  (min ,+), (max,+), (min,*), (max,*)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;icm&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Gibbs (<tt class="docutils literal"><span class="pre">'gibbs'</span></tt>)  (min ,+), (max,*)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;gibbs&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">AStar (<tt class="docutils literal"><span class="pre">'astar'</span></tt>) (min ,+), (max,+), (min,*), (max,*)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;astar&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">LOC (<tt class="docutils literal"><span class="pre">'loc'</span></tt>) (min ,+), (max,+), (min,*), (max,*)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;loc&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Lazy Flipper (<tt class="docutils literal"><span class="pre">'lf'</span></tt>):  (min ,+), (max,+), (min,*), (max,*)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;lf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Graph Cut (<tt class="docutils literal"><span class="pre">'gc'</span></tt>):  (min ,+)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;gc&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Alpha-Beta Swap(<tt class="docutils literal"><span class="pre">'ab-swap'</span></tt>):  (min ,+)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;ab-swap&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Alpha Expansion (<tt class="docutils literal"><span class="pre">'a-expansion'</span></tt>):  (min ,+)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;a-expansion&#39;</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>To infer a gm one need to do the following seps.</p>
<p>Get the parameter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># get an instance of the inference algorithm&#39;s parameter object</span>
<span class="n">param</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;bp&#39;</span><span class="p">,</span><span class="n">accumulator</span><span class="o">=</span><span class="s">&#39;minimizer&#39;</span><span class="p">)</span>
<span class="c"># the same parameter but for inference with a maximizer as accumulator</span>
<span class="n">param</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;bp&#39;</span><span class="p">,</span><span class="n">accumulator</span><span class="o">=</span><span class="s">&#39;maximizer&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If no accumulator is given the most suitable accumulator is choosen.
For a gm with an Adder(+) as operator the accumulator will be a minimizer.
For  =a gm with an Multiplier(*) as operator the accumulator will be a maximizer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#get an instance of the inference algorithm&#39;s parameter object</span>
<span class="n">param</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;bp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Set up the parameter:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># set up the paraemters (this is different for all the inference algorithms)</span>
<span class="n">param</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="p">)</span>
</pre></div>
</div>
<p>Construct the inference / solver object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#get an instance of the optimizer / inference-algorithm</span>
<span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;bp&#39;</span><span class="p">,</span><span class="n">parameter</span><span class="o">=</span><span class="n">param</span><span class="p">,</span><span class="n">accumulator</span><span class="o">=</span><span class="s">&#39;minimizer&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If no accumulator is given the most suitable accumulator is choosen.
For a gm with an Adder(+) as operator the accumulator will be a minimizer.
For  =a gm with an Multiplier(*) as operator the accumulator will be a maximizer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#get an instance of the optimizer / inference-algorithm</span>
<span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;bp&#39;</span><span class="p">,</span><span class="n">parameter</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
</pre></div>
</div>
<p>If no parameter is choosen a parameter with construced with the default parameters will be passed to
the inference object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#get an instance of the optimizer / inference-algorithm</span>
<span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;bp&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Start inference:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">.</span><span class="n">infer</span><span class="p">()</span>
</pre></div>
</div>
<p>Start inference (in this case verbose infernce):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Start inference (in this case verbose infernce where each 10. step is printed):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">printNth</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Start inference (print verbose information in new lines):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">printNth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">multiline</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Start inference (print verbose information in the same line ,more compact verbose information):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inf</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">printNth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">multiline</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Get the inference result</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># get the result states</span>
<span class="n">argmin</span><span class="o">=</span><span class="n">inf</span><span class="o">.</span><span class="n">arg</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="belief-propagation-bp">
<h3><a class="toc-backref" href="#id21">Belief propagation (Bp)</a><a class="headerlink" href="#belief-propagation-bp" title="Permalink to this headline">¶</a></h3>
<p>Assuming a graphical model with the name gm exists,the following code will
minimize a gm with Belief Propagation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#get an instance of the inference algorithm&#39;s parameter object</span>
<span class="n">param</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceParameter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;bp&#39;</span><span class="p">,</span><span class="n">accumulator</span><span class="o">=</span><span class="s">&#39;minimizer&#39;</span><span class="p">)</span>
<span class="c"># set up the paraemters</span>
<span class="n">param</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span><span class="n">damping</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">convergenceBound</span><span class="o">=</span><span class="mf">0.00000001</span><span class="p">)</span>
<span class="c">#get an instance of the optimizer / inference-algorithm</span>
<span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&#39;bp&#39;</span><span class="p">,</span><span class="n">parameter</span><span class="o">=</span><span class="n">param</span><span class="p">,</span><span class="n">accumulator</span><span class="o">=</span><span class="s">&#39;minimizer&#39;</span><span class="p">)</span>
<span class="c"># start inference (in this case verbose infernce)</span>
<span class="n">inf</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="n">true</span><span class="p">)</span>
<span class="c"># get the result states</span>
<span class="n">argmin</span><span class="o">=</span><span class="n">inf</span><span class="o">.</span><span class="n">arg</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="treereweighted-belief-propagation-trbp">
<h3><a class="toc-backref" href="#id22">Treereweighted Belief propagation (Trbp)</a><a class="headerlink" href="#treereweighted-belief-propagation-trbp" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
<div class="section" id="icm">
<h3><a class="toc-backref" href="#id23">ICM</a><a class="headerlink" href="#icm" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
<div class="section" id="gibbs">
<h3><a class="toc-backref" href="#id24">Gibbs</a><a class="headerlink" href="#gibbs" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
<div class="section" id="astar">
<h3><a class="toc-backref" href="#id25">AStar</a><a class="headerlink" href="#astar" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
<div class="section" id="loc">
<h3><a class="toc-backref" href="#id26">LOC</a><a class="headerlink" href="#loc" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
<div class="section" id="lazy-flipper">
<h3><a class="toc-backref" href="#id27">Lazy Flipper</a><a class="headerlink" href="#lazy-flipper" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
<div class="section" id="graph-cut">
<h3><a class="toc-backref" href="#id28">Graph Cut</a><a class="headerlink" href="#graph-cut" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
<div class="section" id="alpha-beta-swap">
<h3><a class="toc-backref" href="#id29">Alpha Beta Swap</a><a class="headerlink" href="#alpha-beta-swap" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
<div class="section" id="alpha-expansion">
<h3><a class="toc-backref" href="#id30">Alpha Expansion</a><a class="headerlink" href="#alpha-expansion" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
<div class="section" id="cplex">
<h3><a class="toc-backref" href="#id31">CPlex</a><a class="headerlink" href="#cplex" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO</p>
</div>
</div>
</div>
</div>
<div class="section" id="opengm-python-examples">
<h1><a class="toc-backref" href="#id32">OpenGM Python Examples</a><a class="headerlink" href="#opengm-python-examples" title="Permalink to this headline">¶</a></h1>
<div class="section" id="potts-model">
<h2><a class="toc-backref" href="#id33">Potts Model</a><a class="headerlink" href="#potts-model" title="Permalink to this headline">¶</a></h2>
<p>This example builds a Potts model on a two dimensional grid:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">opengm</span>

<span class="n">dimx</span><span class="o">=</span><span class="mi">3</span>
<span class="n">dimy</span><span class="o">=</span><span class="mi">3</span>
<span class="n">numVar</span><span class="o">=</span><span class="n">dimx</span><span class="o">*</span><span class="n">dimy</span>
<span class="n">numLabels</span><span class="o">=</span><span class="mi">2</span>
<span class="n">beta</span><span class="o">=</span><span class="mf">0.8</span>

<span class="n">numberOfStates</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numVar</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span><span class="o">*</span><span class="n">numLabels</span>
<span class="n">gm</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">(</span><span class="n">numberOfStates</span><span class="p">,</span><span class="n">operator</span><span class="o">=</span><span class="s">&#39;adder&#39;</span><span class="p">)</span>
<span class="c">#Adding unary function and factors</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimy</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimx</span><span class="p">):</span>
        <span class="n">f1</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">numLabels</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span> <span class="n">f1</span><span class="p">)</span>
        <span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,(</span><span class="n">x</span><span class="o">+</span><span class="n">dimx</span><span class="o">*</span><span class="n">y</span><span class="p">,))</span>
<span class="c">#Adding binary function and factors&quot;</span>
<span class="n">vis</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
<span class="c">#add one binary function (potts fuction)</span>
<span class="n">f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">numLabels</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">numLabels</span><span class="p">,</span><span class="n">numLabels</span><span class="p">)</span><span class="o">*</span><span class="n">beta</span>
<span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numLabels</span><span class="p">):</span>
    <span class="n">f</span><span class="p">[</span><span class="n">l</span><span class="p">,</span><span class="n">l</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c">#add binary factors</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimy</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimx</span><span class="p">):</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">dimx</span><span class="p">):</span>
            <span class="c">#vi as tuple (list and numpy array can also be used as vi&#39;s)</span>
            <span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="o">+</span><span class="n">dimx</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">dimx</span><span class="o">*</span><span class="n">y</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>
        <span class="k">if</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="n">dimy</span><span class="p">):</span>
            <span class="c">#vi as list (tuple and numpy array can also be used as vi&#39;s)</span>
            <span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="n">x</span><span class="o">+</span><span class="n">dimx</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">+</span><span class="n">dimx</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="section" id="markov-chain">
<h2><a class="toc-backref" href="#id34">Markov Chain</a><a class="headerlink" href="#markov-chain" title="Permalink to this headline">¶</a></h2>
<p>This example builds a Markov Chain:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">chainLength</span><span class="o">=</span><span class="mi">10</span>
<span class="n">numLabels</span><span class="o">=</span><span class="mi">4</span>
<span class="n">numberOfStates</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numVar</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span><span class="o">*</span><span class="n">numLabels</span>
<span class="n">gm</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">(</span><span class="n">numberOfStates</span><span class="p">,</span><span class="n">operator</span><span class="o">=</span><span class="s">&#39;adder&#39;</span><span class="p">)</span>
<span class="c">#add some random unaries</span>
<span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chainLength</span><span class="p">):</span>
   <span class="n">unaryFuction</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">numLabels</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
   <span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">unaryFuction</span><span class="p">),[</span><span class="n">vi</span><span class="p">])</span>
<span class="c">#add one 2.order function</span>
<span class="n">f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">numLabels</span><span class="o">*</span><span class="n">numLabels</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">numLabels</span><span class="p">,</span><span class="n">numLabels</span><span class="p">)</span>
<span class="c">#fill function with values...</span>
<span class="c">#.......</span>
<span class="c">#add function</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c">#add factors on a chain of the length 10</span>
<span class="n">n</span><span class="o">=</span><span class="mi">10</span>
<span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chainLength</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
   <span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="n">vi</span><span class="p">,</span><span class="n">vi</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="interpixel-boundary-segmentation">
<h2><a class="toc-backref" href="#id35">Interpixel Boundary Segmentation</a><a class="headerlink" href="#interpixel-boundary-segmentation" title="Permalink to this headline">¶</a></h2>
<p>The following example performs an interpixel boundarie segmentation on a topological grid.
The code uses the function  &#8220;printSolution&#8221; and the class &#8220;TopologicalCoordinateToIndex&#8221;.
The code for thes function/classes is given below the example code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">opengm</span><span class="o">,</span><span class="nn">numpy</span><span class="o">,</span><span class="nn">sys</span>

<span class="c"># model parameter</span>
<span class="n">gridSize</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="c"># size of grid</span>
<span class="n">beta</span><span class="o">=</span><span class="mf">0.7</span>     <span class="c"># bias to choose between under- and over-segmentation</span>
<span class="n">high</span><span class="o">=</span><span class="mi">100</span>       <span class="c"># closedness-enforcing soft-constraint value for forbidden configurations</span>

<span class="c"># size of the topological grid</span>
<span class="n">tGridSize</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">nrOfVariables</span><span class="o">=</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">cToVi</span><span class="o">=</span><span class="n">TopologicalCoordinateToIndex</span><span class="p">(</span><span class="n">gridSize</span><span class="p">)</span>
<span class="c"># some random data on a grid</span>
<span class="n">data</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c"># construct gm</span>
<span class="n">numberOfLabels</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nrOfVariables</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
<span class="n">gm</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">(</span><span class="n">numberOfLabels</span><span class="p">)</span>

<span class="c"># 4th-order closedness-function</span>
<span class="n">fClosedness</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
   <span class="k">for</span> <span class="n">x2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">x3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
         <span class="k">for</span> <span class="n">x4</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">labelsum</span><span class="o">=</span><span class="n">x1</span><span class="o">+</span><span class="n">x2</span><span class="o">+</span><span class="n">x3</span><span class="o">+</span><span class="n">x4</span>
            <span class="k">if</span> <span class="n">labelsum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">labelsum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">0</span> <span class="p">:</span>
               <span class="n">fClosedness</span><span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">,</span><span class="n">x3</span><span class="p">,</span><span class="n">x4</span><span class="p">]</span><span class="o">=</span><span class="n">high</span>
<span class="n">fidClosedness</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">fClosedness</span><span class="p">)</span>
<span class="c"># for each boundary in the grid, i.e. for each variable</span>
<span class="c"># of the model, add one 1st order functions</span>
<span class="c"># and one 1st order factor</span>
<span class="c"># and for each junction of four inter-pixel edges on the grid,</span>
<span class="c"># one factor is added that connects the corresponding variable</span>
<span class="c"># indices and refers to the closedness-function</span>
<span class="k">for</span> <span class="n">yt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tGridSize</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
   <span class="k">for</span> <span class="n">xt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tGridSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
      <span class="c"># unaries</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">xt</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">yt</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
         <span class="n">gradient</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span>  <span class="n">data</span><span class="p">[</span><span class="n">xt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">yt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span><span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">xt</span><span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">xt</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="n">yt</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">yt</span> <span class="o">%</span> <span class="mi">2</span><span class="p">])</span>
         <span class="n">f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">beta</span><span class="o">*</span><span class="n">gradient</span> <span class="p">,</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">gradient</span><span class="p">)],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
         <span class="k">print</span> <span class="n">gm</span><span class="p">[</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">),[</span><span class="n">cToVi</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span><span class="n">yt</span><span class="p">)])]</span><span class="o">.</span><span class="n">asNumpy</span><span class="p">()</span>
      <span class="c"># high order factors (4.th order)</span>
      <span class="k">if</span> <span class="n">xt</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">yt</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">:</span>
         <span class="n">vi</span><span class="o">=</span><span class="p">[</span><span class="n">cToVi</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">xt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">yt</span><span class="p">),</span><span class="n">cToVi</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">xt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">yt</span><span class="p">),</span><span class="n">cToVi</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">cToVi</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
         <span class="n">vi</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span>
         <span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fidClosedness</span><span class="p">,</span><span class="n">vi</span><span class="p">)</span>

<span class="n">param</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceParameter</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&quot;lf&quot;</span><span class="p">)</span>
<span class="n">param</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">maxSubgraphSize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">inf</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">inferenceAlgorithm</span><span class="p">(</span><span class="n">gm</span><span class="o">=</span><span class="n">gm</span><span class="p">,</span><span class="n">alg</span><span class="o">=</span><span class="s">&quot;lf&quot;</span><span class="p">,</span><span class="n">parameter</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>
<span class="n">inf</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">arg</span><span class="o">=</span><span class="n">inf</span><span class="o">.</span><span class="n">arg</span><span class="p">()</span>
<span class="n">printSolution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">arg</span><span class="p">)</span>
</pre></div>
</div>
<p>TopologicalCoordinateToIndex is used to map the coorinates of the two dimensional topological
grid to a one dimensial variable index:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TopologicalCoordinateToIndex</span><span class="p">:</span>
   <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span> <span class="p">,</span><span class="n">geometricGridSize</span><span class="p">)</span> <span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">gridSize</span><span class="o">=</span><span class="n">geometricGridSize</span>
   <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span><span class="n">ty</span><span class="p">)</span> <span class="p">:</span>
      <span class="k">return</span> <span class="n">tx</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ty</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">((</span><span class="n">ty</span> <span class="o">+</span> <span class="n">ty</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gridSize</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>printSolution is used to visualize the result of the inference / optimiation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">printSolution</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">solution</span><span class="p">):</span>
   <span class="n">helper</span><span class="o">=</span><span class="n">TopologicalCoordinateToIndex</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
   <span class="k">for</span>  <span class="n">x</span>   <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;___&quot;</span><span class="p">)</span>
   <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
   <span class="k">for</span>  <span class="n">y</span>   <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;|&quot;</span><span class="p">)</span>
      <span class="k">for</span>  <span class="n">x</span>   <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
         <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;   &quot;</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">:</span>
            <span class="k">if</span> <span class="n">solution</span><span class="p">[</span><span class="n">helper</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
               <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;___&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;   &quot;</span><span class="p">)</span>
         <span class="k">elif</span>   <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>  <span class="p">:</span>
            <span class="k">if</span> <span class="n">solution</span><span class="p">[</span><span class="n">helper</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
               <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot; | &quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;   &quot;</span><span class="p">)</span>
         <span class="k">elif</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
               <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot; * &quot;</span><span class="p">)</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;|</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
   <span class="k">for</span>  <span class="n">x</span>   <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;___&quot;</span><span class="p">)</span>
   <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="opengm-python-snippets">
<h1><a class="toc-backref" href="#id36">OpenGM Python Snippets</a><a class="headerlink" href="#opengm-python-snippets" title="Permalink to this headline">¶</a></h1>
<div class="section" id="inspect-a-graphical-model">
<h2><a class="toc-backref" href="#id37">Inspect a Graphical Model</a><a class="headerlink" href="#inspect-a-graphical-model" title="Permalink to this headline">¶</a></h2>
<p>The following code shows a lot of usefull functions to inspect a gm and the factors of the gm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&quot;gm :&quot;</span><span class="p">,</span><span class="n">gm</span>
<span class="k">print</span> <span class="s">&quot;number of Variables : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="o">.</span><span class="n">numberOfVariables</span>
<span class="k">print</span> <span class="s">&quot;number of Factors :&quot;</span><span class="p">,</span> <span class="n">gm</span><span class="o">.</span><span class="n">numberOfFactors</span>
<span class="k">print</span> <span class="s">&quot;is Acyclic :&quot;</span> <span class="p">,</span> <span class="n">gm</span><span class="o">.</span><span class="n">isAcyclic</span><span class="p">()</span>

<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">numberOfVariables</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&quot; vi=&quot;</span><span class="p">,</span><span class="n">v</span><span class="p">,</span> <span class="s">&quot; number of labels : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot; factors depeding on vi=&quot;</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="s">&quot; : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="o">.</span><span class="n">numberOfFactorsForVariable</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">numberOfFactors</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&quot;gm[&quot;</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="s">&quot;]&quot;</span><span class="p">,</span>  <span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">&quot;gm[&quot;</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="s">&quot;].shape&quot;</span><span class="p">,</span>  <span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="c">#convert shape to tuple,list or numpy ndarray</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">asTuple</span><span class="p">()</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">asList</span><span class="p">()</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">asNumpy</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;gm[&quot;</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="s">&quot;].variableIndices&quot;</span><span class="p">,</span>  <span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">variableIndices</span>
    <span class="c">#convert variableIndices to tuple,list or numpy ndarray</span>
    <span class="n">shape</span><span class="o">=</span> <span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">variableIndices</span><span class="o">.</span><span class="n">asTuple</span><span class="p">()</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">variableIndices</span><span class="o">.</span><span class="n">asList</span><span class="p">()</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">variableIndices</span><span class="o">.</span><span class="n">asNumpy</span><span class="p">()</span>
    <span class="c">#convert the factor to a numpy ndarray (a new numpy ndarray is allocated)</span>
    <span class="k">print</span> <span class="s">&quot;factors values:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">asNumpy</span><span class="p">()</span>
    <span class="c">#factors min ,max ,sum and product values</span>
    <span class="k">print</span> <span class="s">&quot;min : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;max : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;sum : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;product : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">product</span><span class="p">()</span>
    <span class="c">#factors properties</span>
    <span class="k">print</span> <span class="s">&quot;isPotts : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">isPotts</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;isGeneralizedPotts : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">isGeneralizedPotts</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;isSubmodular : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">isSubmodular</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;isSquaredDifference : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">isSquaredDifference</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;isTruncatedSquaredDifference : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">isTruncatedSquaredDifference</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;isAbsoluteDifference : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">isAbsoluteDifference</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;isTruncatedAbsoluteDifference : &quot;</span><span class="p">,</span><span class="n">gm</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">isTruncatedAbsoluteDifference</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="iterate-over-a-factors-values">
<h2><a class="toc-backref" href="#id38">Iterate over a Factors Values</a><a class="headerlink" href="#iterate-over-a-factors-values" title="Permalink to this headline">¶</a></h2>
<p>A direct access via coordinate.
The type of the coordinate can be a tuple ( <tt class="docutils literal"><span class="pre">c=(1,3,2)</span></tt> ) , a list  ( <tt class="docutils literal"><span class="pre">c=[1,1,3]</span></tt> )  or a numpy array ( <tt class="docutils literal"><span class="pre">c=numpy.array([2,1,3],dtype=numpy.uint64)</span></tt> ).
Assuming a third order factor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">factor</span><span class="o">=</span><span class="n">gm</span><span class="p">[</span><span class="n">someFactorIndex</span><span class="p">]</span>
<span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">2</span><span class="p">)):</span>
   <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">1</span><span class="p">)):</span>
      <span class="k">for</span> <span class="n">l0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">factor</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">0</span><span class="p">)):</span>
         <span class="c">#coordinate / label sequence as tuple</span>
         <span class="k">print</span> <span class="n">factor</span><span class="p">[</span> <span class="p">(</span><span class="n">l0</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">)</span> <span class="p">]</span>
</pre></div>
</div>
<p>A factors value table can also be copied to a new allocated numpy ndarray:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">factor</span><span class="o">=</span><span class="n">gm</span><span class="p">[</span><span class="n">someFactorIndex</span><span class="p">]</span>
<span class="n">valueTable</span><span class="o">=</span><span class="n">factor</span><span class="o">.</span><span class="n">asNumpy</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="opengm-python-reference-documentation">
<h1><a class="toc-backref" href="#id39">OpenGM Python Reference Documentation</a><a class="headerlink" href="#opengm-python-reference-documentation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2><a class="toc-backref" href="#id40">opengm</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="graphicalmodel">
<h3><a class="toc-backref" href="#id41">GraphicalModel</a><a class="headerlink" href="#graphicalmodel" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="opengm.graphicalModel">
<tt class="descclassname">opengm.</tt><tt class="descname">graphicalModel</tt><big>(</big><em>numberOfLabels</em>, <em>operator='adder'</em><big>)</big><a class="headerlink" href="#opengm.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The namespace <tt class="docutils literal"><span class="pre">opengm.opengmcore._opengmcore.adder</span></tt> is reachable via <tt class="docutils literal"><span class="pre">opengm.adder</span></tt>.
In the reference documentation of the graphical model only <tt class="docutils literal"><span class="pre">opengm.adder</span></tt> is considered,
since the documentation of <tt class="docutils literal"><span class="pre">opengm.multiplier</span></tt> ( <tt class="docutils literal"><span class="pre">opengm.opengmcore._opengmcore.multiplier</span></tt>) would be
exactly the same.</p>
<dl class="class">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel">
<em class="property">class </em><tt class="descclassname">opengm.opengmcore._opengmcore.adder.</tt><tt class="descname">GraphicalModel</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>The central class of opengm which holds the factor graph and functions of the graphical model</p>
<dl class="docutils">
<dt>__init__( (object)arg1) -&gt; None :</dt>
<dd>Construct an empty graphical model with no variables</dd>
<dt>__init__( (object)arg1, (object)numberOfLabels) -&gt; object :</dt>
<dd><p class="first">Construct a gm from a numpy array which holds the number of labels for all variables.</p>
<blockquote>
<div>The gm will have as many variables as the length of the numpy array</div></blockquote>
<p>Args:</p>
<blockquote class="last">
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
</dd>
<dt>__init__( (object)arg1, (list)numberOfLabels) -&gt; object :</dt>
<dd><p class="first">Construct a gm from a python list which holds the number of labels for all variables.</p>
<p>The gm will have as many variables as the length of the list
Args:</p>
<blockquote class="last">
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
</dd>
</dl>
<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(int)factorIndex</em><big>)</big> &rarr; Factor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a factor of the graphical model</p>
<p>Args:</p>
<blockquote>
<div><p>factorIndex: index of a factor w.r.t. the gm</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">factorIndex</span></tt> has to be a integral scalar:</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A const reference to the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt>.</dd>
<dt>Example:</dt>
<dd>factor=gm[someFactorIndex]</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>(object)arg1</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Construct an empty graphical model with no variables</div></blockquote>
<dl class="docutils">
<dt>__init__( (object)arg1, (object)numberOfLabels) -&gt; object :</dt>
<dd><p class="first">Construct a gm from a numpy array which holds the number of labels for all variables.</p>
<blockquote>
<div>The gm will have as many variables as the length of the numpy array</div></blockquote>
<p>Args:</p>
<blockquote class="last">
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
</dd>
<dt>__init__( (object)arg1, (list)numberOfLabels) -&gt; object :</dt>
<dd><p class="first">Construct a gm from a python list which holds the number of labels for all variables.</p>
<p>The gm will have as many variables as the length of the list
Args:</p>
<blockquote class="last">
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.__str__">
<tt class="descname">__str__</tt><big>(</big><em>(GraphicalModel)arg1</em><big>)</big> &rarr; str :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.__str__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Print a a gm as stringReturns:</dt>
<dd>A string which describes the graphical model</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.addFactor">
<tt class="descname">addFactor</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(FunctionIdentifier)fid</em>, <em>(object)variableIndices</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.addFactor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Adds a factor to the gm.</p>
<blockquote>
<div><p>The factors will is connected to the function indicated with &#8220;fid&#8221;.</p>
<p>The factors variables are given by <tt class="docutils literal"><span class="pre">variableIndices</span></tt>. &#8220;variableIndices&#8221; has to be sorted.</p>
<p>In this overloading of &#8220;addFactor&#8221; the type of &#8220;variableIndices&#8221;  has to be a 1d numpy array</p>
</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>variableIndices: the factors variables</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">variableIndices</span></tt> has to be sorted.</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>index of the added factor .</dd>
<dt>Example</dt>
<dd><p class="first">adding a factor to the graphical model:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="c"># assuming there is a function &quot;f&quot;</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">vis</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
<span class="c">#vis has to be sorted </span>
<span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">vis</span><span class="p">)</span>    
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>addFactor( (GraphicalModel)arg1, (FunctionIdentifier)fid, (tuple)variableIndices) -&gt; long :</dt>
<dd><p class="first">Adds a factor to the gm.</p>
<blockquote>
<div><p>The factors will is connected to the function indicated with &#8220;fid&#8221;.</p>
<p>The factors variables are given by <tt class="docutils literal"><span class="pre">variableIndices</span></tt>. &#8220;variableIndices&#8221; has to be sorted.</p>
<p>In this overloading of &#8220;addFactor&#8221; the type of &#8220;variableIndices&#8221;  has to be a tuple</p>
</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>variableIndices: the factors variables</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">variableIndices</span></tt> has to be sorted.</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>Returns:</dt>
<dd>index of the added factor .</dd>
<dt>Example:</dt>
<dd><p class="first">adding a factor to the graphical model:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="c"># assuming there is a function &quot;f&quot;</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">vis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="c">#vis has to be sorted </span>
<span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">vis</span><span class="p">)</span>    
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt>addFactor( (GraphicalModel)arg1, (FunctionIdentifier)fid, (list)variableIndices) -&gt; long :</dt>
<dd><p class="first">Adds a factor to the gm.</p>
<blockquote>
<div><p>The factors will is connected to the function indicated with &#8220;fid&#8221;.</p>
<p>The factors variables are given by <tt class="docutils literal"><span class="pre">variableIndices</span></tt>. &#8220;variableIndices&#8221; has to be sorted.</p>
<p>In this overloading of &#8220;addFactor&#8221; the type of &#8220;variableIndices&#8221;  has to be a list</p>
</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>variableIndices: the factors variables</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">variableIndices</span></tt> has to be sorted.</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>Returns:</dt>
<dd>index of the added factor .</dd>
<dt>Example:</dt>
<dd><p class="first">adding a factor to the graphical model:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="c"># assuming there is a function &quot;f&quot;</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">vis</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="c">#vis has to be sorted </span>
<span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">vis</span><span class="p">)</span>    
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.addFunction">
<tt class="descname">addFunction</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(object)function</em><big>)</big> &rarr; FunctionIdentifier :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.addFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a function to the graphical model.Args:</p>
<blockquote>
<div><p>function: a function/ value table</p>
<blockquote>
<div>The type of &#8220;function&#8221;  has to be a numpy ndarray.</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A function identifier (fid) .</p>
<blockquote class="last">
<div>This fid is used to connect a factor to this function</div></blockquote>
</dd>
<dt>Examples:</dt>
<dd><p class="first">Adding 1th-order function with the shape [3]:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">0.1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Adding 2th-order function with  the shape [4,4]:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="c">#fill the function with values</span>
<span class="c">#..........</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Adding 3th-order function with the shape [4,5,2]:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="c">#fill the function with values</span>
<span class="c">#..........</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.assign">
<tt class="descname">assign</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(object)numberOfLabels</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.assign" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Assign a gm from a python list which holds the number of labels for all variables.</p>
<blockquote>
<div>The gm will have as many variables as the length of the numpy array</div></blockquote>
<p>Args:</p>
<blockquote>
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>assign( (GraphicalModel)arg1, (list)numberOfLabels) -&gt; None :</dt>
<dd><p class="first">Assign a gm from a python list which holds the number of labels for all variables.</p>
<blockquote>
<div>The gm will have as many variables as the length of the list</div></blockquote>
<p>Args:</p>
<blockquote>
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
<dl class="last docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.evaluate">
<tt class="descname">evaluate</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(object)labels</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Evaluates the factors of given a labelSequence.</p>
<blockquote>
<div>In this overloading the type of  &#8220;labelSequence&#8221; has to be a 1d numpy array</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>labelSequence: A labeling for all variables.</p>
<blockquote>
<div>Has to as long as <tt class="docutils literal"><span class="pre">gm.numberOfVariables</span></tt>.</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The energy / probability for the given <tt class="docutils literal"><span class="pre">labelSequence</span></tt></dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>evaluate( (GraphicalModel)arg1, (list)labels) -&gt; float :</dt>
<dd><p class="first">Evaluates the factors of given a labelSequence.</p>
<blockquote>
<div>In this overloading the type of  &#8220;labelSequence&#8221; has to be a list</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>labelSequence: A labeling for all variables.</p>
<blockquote>
<div>Has to as long as <tt class="docutils literal"><span class="pre">gm.numberOfVariables</span></tt>.</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>Returns:</dt>
<dd>The energy / probability for the given <tt class="docutils literal"><span class="pre">labelSequence</span></tt></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.factorOfVariable">
<tt class="descname">factorOfVariable</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)variableIndex</em>, <em>(long)factorIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.factorOfVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variable index of a varible which is connected to a factor.</p>
<p>Args:</p>
<blockquote>
<div><p>factorIndex: index of a variable w.r.t the gm</p>
<p>variableIndex: index of a factor w.r.t the variable at <tt class="docutils literal"><span class="pre">variableInex</span></tt></p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The variableIndex w.r.t. the gm of the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.isAcyclic">
<tt class="descname">isAcyclic</tt><big>(</big><em>(GraphicalModel)arg1</em><big>)</big> &rarr; bool :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.isAcyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the graphical is isAcyclic.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">True if model has no loops / is acyclic</p>
<p class="last">False if model has loops / is not acyclic</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfFactors">
<tt class="descname">numberOfFactors</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>The Number of factors of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfFactorsOfVariable">
<tt class="descname">numberOfFactorsOfVariable</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)variableIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfFactorsOfVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of factors which are connected to a variable</p>
<p>Args:</p>
<blockquote>
<div>variableIndex: index of a variable w.r.t. the gm</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">The nubmer of variables which are connected</p>
<blockquote class="last">
<div>to the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfLabels">
<tt class="descname">numberOfLabels</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)variableIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of labels for a variable</p>
<p>Args:</p>
<blockquote>
<div>variableIndex: index to a variable in this gm</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The nubmer of labels for the variable at <tt class="docutils literal"><span class="pre">variableIndex</span></tt></dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfVariables">
<tt class="descname">numberOfVariables</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of variables of the graphical modelReturns:
Number of variables.</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfVariablesOfFactor">
<tt class="descname">numberOfVariablesOfFactor</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)factorIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfVariablesOfFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of variables which are connected to a factor</p>
<p>Args:</p>
<blockquote>
<div>factorIndex: index to a factor in this gm</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">The nubmer of variables which are connected</p>
<blockquote class="last">
<div>to the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.operator">
<tt class="descname">operator</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.operator" title="Permalink to this definition">¶</a></dt>
<dd><p>The operator of the graphical model as a string</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.space">
<tt class="descname">space</tt><big>(</big><em>(GraphicalModel)arg1</em><big>)</big> &rarr; Space :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.space" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variable space of the graphical model</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A const reference to space of the gm.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.variableOfFactor">
<tt class="descname">variableOfFactor</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)factorIndex</em>, <em>(long)variableIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.variableOfFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variable index of a varible which is connected to a factor.</p>
<p>Args:</p>
<blockquote>
<div><p>factorIndex: index of a factor w.r.t the gm</p>
<p>variableIndex: index of a variable w.r.t the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The variableIndex w.r.t. the gm of the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="factor">
<h3><a class="toc-backref" href="#id42">Factor</a><a class="headerlink" href="#factor" title="Permalink to this headline">¶</a></h3>
<p>The namespace <tt class="docutils literal"><span class="pre">opengm.opengmcore._opengmcore.adder</span></tt> is reachable via <tt class="docutils literal"><span class="pre">opengm.adder</span></tt>.
In the reference documentation of the factor model only <tt class="docutils literal"><span class="pre">opengm.adder</span></tt> is considered,
since the documentation of <tt class="docutils literal"><span class="pre">opengm.multiplier</span></tt> ( <tt class="docutils literal"><span class="pre">opengm.opengmcore._opengmcore.multiplier</span></tt>) would be
exactly the same.</p>
<dl class="class">
<dt id="opengm.opengmcore._opengmcore.adder.Factor">
<em class="property">class </em><tt class="descclassname">opengm.opengmcore._opengmcore.adder.</tt><tt class="descname">Factor</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__add__">
<tt class="descname">__add__</tt><big>(</big><em>(Factor)arg1</em>, <em>(Factor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>__add__( (Factor)arg1, (float)arg2) -&gt; object</p>
<p>__add__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__div__">
<tt class="descname">__div__</tt><big>(</big><em>(Factor)arg1</em>, <em>(Factor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__div__" title="Permalink to this definition">¶</a></dt>
<dd><p>__div__( (Factor)arg1, (float)arg2) -&gt; object</p>
<p>__div__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Access the factors value table for a given label sequence.In this overloading the type of the label sequence has to be a 1d numpy ndarray:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">TODO</span>  
</pre></div>
</div>
</div></blockquote>
<p>__getitem__( (Factor)arg1, (tuple)arg2) -&gt; float</p>
<p>__getitem__( (Factor)arg1, (list)arg2) -&gt; float</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__instance_size__">
<tt class="descname">__instance_size__</tt><em class="property"> = 36</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__instance_size__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'opengm.opengmcore'</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__mul__">
<tt class="descname">__mul__</tt><big>(</big><em>(Factor)arg1</em>, <em>(Factor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__mul__( (Factor)arg1, (float)arg2) -&gt; object</p>
<p>__mul__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__radd__">
<tt class="descname">__radd__</tt><big>(</big><em>(Factor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__radd__" title="Permalink to this definition">¶</a></dt>
<dd><p>__radd__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__rdiv__">
<tt class="descname">__rdiv__</tt><big>(</big><em>(Factor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__rdiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rdiv__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__reduce__">
<tt class="descname">__reduce__</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__rmul__">
<tt class="descname">__rmul__</tt><big>(</big><em>(Factor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rmul__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__rsub__">
<tt class="descname">__rsub__</tt><big>(</big><em>(Factor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rsub__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__str__">
<tt class="descname">__str__</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; str<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__str__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__sub__">
<tt class="descname">__sub__</tt><big>(</big><em>(Factor)arg1</em>, <em>(Factor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__sub__( (Factor)arg1, (float)arg2) -&gt; object</p>
<p>__sub__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.asIndependentFactor">
<tt class="descname">asIndependentFactor</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; IndependentFactor<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.asIndependentFactor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.asNumpy">
<tt class="descname">asNumpy</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.asNumpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.copyValues">
<tt class="descname">copyValues</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.copyValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the value table of a factor to a new allocated 1d-numpy array in last-coordinate-major-order</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.copyValuesSwitchedOrder">
<tt class="descname">copyValuesSwitchedOrder</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.copyValuesSwitchedOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the value table of a factor to a new allocated 1d-numpy array in first-coordinate-major-order</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.functionIndex">
<tt class="descname">functionIndex</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.functionIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the function index of a factor, which indicated the index of the function this factor is connected to</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.functionType">
<tt class="descname">functionType</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.functionType" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the function type index of a factorm which indicated the type of the function this factor is connected to</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isAbsoluteDifference">
<tt class="descname">isAbsoluteDifference</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isAbsoluteDifference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isGeneralizedPotts">
<tt class="descname">isGeneralizedPotts</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isGeneralizedPotts" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the factors value table can be written as generalized Potts function</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isPotts">
<tt class="descname">isPotts</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isPotts" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the factors value table can be written as Potts function</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isSquaredDifference">
<tt class="descname">isSquaredDifference</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isSquaredDifference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isSubmodular">
<tt class="descname">isSubmodular</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isSubmodular" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the factor is submodular</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isTruncatedAbsoluteDifference">
<tt class="descname">isTruncatedAbsoluteDifference</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isTruncatedAbsoluteDifference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isTruncatedSquaredDifference">
<tt class="descname">isTruncatedSquaredDifference</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isTruncatedSquaredDifference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.max">
<tt class="descname">max</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)accVariables</em><big>)</big> &rarr; IndependentFactor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.max" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a 1d numpy.ndarray</div></blockquote>
<dl class="docutils">
<dt>max( (Factor)arg1, (tuple)accVariables) -&gt; IndependentFactor :</dt>
<dd>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a tuple</dd>
<dt>max( (Factor)arg1, (list)accVariables) -&gt; IndependentFactor :</dt>
<dd>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt>. 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a list</dd>
<dt>max( (Factor)arg1) -&gt; float :</dt>
<dd>Get the maximum value of the factor ( the maximum scalar in the factors value table)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.min">
<tt class="descname">min</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)accVariables</em><big>)</big> &rarr; IndependentFactor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.min" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a 1d numpy.ndarray</div></blockquote>
<dl class="docutils">
<dt>min( (Factor)arg1, (tuple)accVariables) -&gt; IndependentFactor :</dt>
<dd>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a tuple</dd>
<dt>min( (Factor)arg1, (list)accVariables) -&gt; IndependentFactor :</dt>
<dd>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt>. 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a list</dd>
<dt>min( (Factor)arg1) -&gt; float :</dt>
<dd>Get the minimum value of the factor ( the minimum scalar in the factors value table)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.numberOfLabels">
<tt class="descname">numberOfLabels</tt><big>(</big><em>(Factor)arg1</em>, <em>(long)variableIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.numberOfLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of labels for a variable of the
factor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="p">)</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span> <span class="p">)</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span> <span class="p">)</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">5</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.numberOfVariables">
<tt class="descname">numberOfVariables</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.numberOfVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of variables which are connected to the
factor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#assuming gm,fid2 and fid3 exist:</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfVariables</span><span class="o">==</span><span class="mi">2</span> <span class="p">)</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid3</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfVariables</span><span class="o">==</span><span class="mi">3</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.product">
<tt class="descname">product</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)accVariables</em><big>)</big> &rarr; IndependentFactor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.product" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Multiply / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a 1d numpy.ndarray</div></blockquote>
<dl class="docutils">
<dt>product( (Factor)arg1, (tuple)accVariables) -&gt; IndependentFactor :</dt>
<dd>Multiply / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a tuple</dd>
<dt>product( (Factor)arg1, (list)accVariables) -&gt; IndependentFactor :</dt>
<dd>Multiply / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt>. 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a list</dd>
<dt>product( (Factor)arg1) -&gt; float :</dt>
<dd>Get the product of all values of the factor</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of a factor, which is a sequence of the number of lables for all variables which are connected to this factor</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.size">
<tt class="descname">size</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of entries in the factor&#8217;s value
table:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">4</span> <span class="p">)</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">8</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.sum">
<tt class="descname">sum</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)accVariables</em><big>)</big> &rarr; IndependentFactor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.sum" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Integrate / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a 1d numpy.ndarray</div></blockquote>
<dl class="docutils">
<dt>sum( (Factor)arg1, (tuple)accVariables) -&gt; IndependentFactor :</dt>
<dd>Integrate / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a tuple</dd>
<dt>sum( (Factor)arg1, (list)accVariables) -&gt; IndependentFactor :</dt>
<dd>Integrate / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt>. 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a list</dd>
<dt>sum( (Factor)arg1) -&gt; float :</dt>
<dd>Get the sum of all values of the factor</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.variableIndices">
<tt class="descname">variableIndices</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.variableIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variable indices of a factor (the indices of all variables which are connected to this factor)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="independentfactor">
<h3><a class="toc-backref" href="#id43">IndependentFactor</a><a class="headerlink" href="#independentfactor" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor">
<em class="property">class </em><tt class="descclassname">opengm.opengmcore._opengmcore.</tt><tt class="descname">IndependentFactor</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.PyIndependentFactor">
<tt class="descname">PyIndependentFactor</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.PyIndependentFactor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__add__">
<tt class="descname">__add__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>__add__( (IndependentFactor)arg1, (float)arg2) -&gt; object</p>
<p>__add__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__add__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__div__">
<tt class="descname">__div__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__div__" title="Permalink to this definition">¶</a></dt>
<dd><p>__div__( (IndependentFactor)arg1, (float)arg2) -&gt; object</p>
<p>__div__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__div__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(tuple)arg2</em><big>)</big> &rarr; float<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>__getitem__( (IndependentFactor)arg1, (list)arg2) -&gt; float</p>
<p>__getitem__( (IndependentFactor)arg1, (object)arg2) -&gt; float</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__iadd__">
<tt class="descname">__iadd__</tt><big>(</big><em>(object)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__iadd__" title="Permalink to this definition">¶</a></dt>
<dd><p>__iadd__( (object)arg1, (float)arg2) -&gt; object</p>
<p>__iadd__( (object)arg1, (Factor)arg2) -&gt; object</p>
<p>__iadd__( (object)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__idiv__">
<tt class="descname">__idiv__</tt><big>(</big><em>(object)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__idiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>__idiv__( (object)arg1, (float)arg2) -&gt; object</p>
<p>__idiv__( (object)arg1, (Factor)arg2) -&gt; object</p>
<p>__idiv__( (object)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__imul__">
<tt class="descname">__imul__</tt><big>(</big><em>(object)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__imul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__imul__( (object)arg1, (float)arg2) -&gt; object</p>
<p>__imul__( (object)arg1, (Factor)arg2) -&gt; object</p>
<p>__imul__( (object)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__instance_size__">
<tt class="descname">__instance_size__</tt><em class="property"> = 60</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__instance_size__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__isub__">
<tt class="descname">__isub__</tt><big>(</big><em>(object)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__isub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__isub__( (object)arg1, (float)arg2) -&gt; object</p>
<p>__isub__( (object)arg1, (Factor)arg2) -&gt; object</p>
<p>__isub__( (object)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'opengm.opengmcore'</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__mul__">
<tt class="descname">__mul__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__mul__( (IndependentFactor)arg1, (float)arg2) -&gt; object</p>
<p>__mul__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__mul__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__radd__">
<tt class="descname">__radd__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__radd__" title="Permalink to this definition">¶</a></dt>
<dd><p>__radd__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__radd__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__rdiv__">
<tt class="descname">__rdiv__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__rdiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rdiv__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__rdiv__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__reduce__">
<tt class="descname">__reduce__</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__rmul__">
<tt class="descname">__rmul__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rmul__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__rmul__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__rsub__">
<tt class="descname">__rsub__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rsub__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__rsub__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__str__">
<tt class="descname">__str__</tt><big>(</big><em>(IndependentFactor)arg1</em><big>)</big> &rarr; str<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__str__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__sub__">
<tt class="descname">__sub__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__sub__( (IndependentFactor)arg1, (float)arg2) -&gt; object</p>
<p>__sub__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__sub__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.asNumpy">
<tt class="descname">asNumpy</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.asNumpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.copyValuesSwitchedOrder">
<tt class="descname">copyValuesSwitchedOrder</tt><big>(</big><em>(IndependentFactor)arg1</em><big>)</big> &rarr; numpy.ndarray<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.copyValuesSwitchedOrder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.min">
<tt class="descname">min</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; IndependentFactor<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.min" title="Permalink to this definition">¶</a></dt>
<dd><p>min( (IndependentFactor)arg1, (tuple)arg2) -&gt; IndependentFactor</p>
<p>min( (IndependentFactor)arg1, (list)arg2) -&gt; IndependentFactor</p>
<p>min( (IndependentFactor)arg1) -&gt; float</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.minInplace">
<tt class="descname">minInplace</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.minInplace" title="Permalink to this definition">¶</a></dt>
<dd><p>minInplace( (IndependentFactor)arg1, (tuple)arg2) -&gt; None</p>
<p>minInplace( (IndependentFactor)arg1, (list)arg2) -&gt; None</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.numberOfLabels">
<tt class="descname">numberOfLabels</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(long)arg2</em><big>)</big> &rarr; long<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.numberOfLabels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.numberOfVariables">
<tt class="descname">numberOfVariables</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.numberOfVariables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of a independent factor, 
which is a sequence of the number of lables for all variables which are connected to this factor</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="opengm-inference">
<h2><a class="toc-backref" href="#id44">opengm.inference</a><a class="headerlink" href="#opengm-inference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3><a class="toc-backref" href="#id45">AStar</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AStar">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AStar</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar" title="Permalink to this definition">¶</a></dt>
<dd><p>A star search algorithm:</p>
<p>cite: Kappes, J. H. :&#8221;Inference on Highly-Connected Discrete Graphical Models with Applications to Visual Object Recognition &#8221;,Ph.D. Thesis 2011.</p>
<p>Bergtholdt, M. &amp; Kappes, J. H. &amp; Schnoerr, C.:&#8221;<a class="reference external" href="http://hci.iwr.uni-heidelberg.de/Staff/jkappes/publications/dagm2006.pdf">Learning of Graphical Models and Efficient Inference for Object Class Recognition</a>&#8221;,  DAGM 2006</p>
<p>Bergtholdt, M. &amp; Kappes, J. H. &amp; Schmidt, S. &amp; Schnoerr, C.: &#8220;<a class="reference external" href="https://www.inf.tu-dresden.de/content/institutes/ki/is/HS_SS09_Papers/A_Study_of_Parts_Based_Object_Class_Detection_Using_Complete_Graphs.pdf">A Study of Parts-Based Object Class Detection Using Complete Graphs</a>&#8221;,  DAGM 2006</p>
<p>limitations: graph must be small enough</p>
<p>guarantees: global optimal</p>
<p>The AStar-Algo transform the problem into a shortest path problem in an exponentially large graph.
Due to the problem structure, this graph can be represented implicitly!
To find the shortest path we perform a best first search and use a admissable tree-based heuristic
to underestimate the cost to a goal node.
This lower bound allows us to reduce the search to an manageable 
subspace of the exponentially large search-space.</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (AStarParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.arg">
<tt class="descname">arg</tt><big>(</big><em>(AStar)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (AStar)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.bound">
<tt class="descname">bound</tt><big>(</big><em>(AStar)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(AStar)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.infer">
<tt class="descname">infer</tt><big>(</big><em>(AStar)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.reset">
<tt class="descname">reset</tt><big>(</big><em>(AStar)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(AStar)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (AStar)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AStarParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.heuristic">
<tt class="descname">heuristic</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>heuristic can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.default</span></tt> :default AStar heuristc (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.standart</span></tt> : standart AStar heuristic</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.fast</span></tt> : fast AStar heuristic for second order gm&#8217;s</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.maxHeapSize">
<tt class="descname">maxHeapSize</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.maxHeapSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum size of the heap which is used while inference</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.numberOfOpt">
<tt class="descname">numberOfOpt</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.numberOfOpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Select which n best states should be searched for while inference:</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.obectiveBound">
<tt class="descname">obectiveBound</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.obectiveBound" title="Permalink to this definition">¶</a></dt>
<dd><p>AStar objective bound.</p>
<p>A good bound will speedup inference</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.set">
<tt class="descname">set</tt><big>(</big><em>(AStarParameter)arg1</em><span class="optional">[</span>, <em>(AStarHeuristic)heuristic=opengm.opengmcore._opengmcore.AStarHeuristic.default</em><span class="optional">[</span>, <em>(float)bound=inf</em><span class="optional">[</span>, <em>(int)maxHeapSize=3000000</em><span class="optional">[</span>, <em>(int)numberOfOpt=1</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>heuristic: Number of message passing updates</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.default</span></tt> :default AStar heuristc (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.standart</span></tt> : stanart AStar heuristic</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.fast</span></tt> : fast AStar heuristic for second order gm&#8217;s</p>
</div></blockquote>
<p>bound: AStar objective bound.</p>
<blockquote>
<div>A good bound will speedup inference (default = neutral value)</div></blockquote>
<p>maxHeapSize: Maximum size of the heap which is used while inference (default=3000000)</p>
<p>numberOfOpt: Select which n best states should be searched for while inference (default=1):</p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id3">
<h3><a class="toc-backref" href="#id46">Belief Propagation (Bp)</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.Bp">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">Bp</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp" title="Permalink to this definition">¶</a></dt>
<dd><p>Belief Propagation (Bp):</p>
<p>cite: Cf. F. R. Kschischang, B. J. Frey and H.-A. Loeliger:&#8221;<a class="reference external" href="http://www.cs.utoronto.ca/~radford/csc2506/factor.pdf">Factor Graphs and the Sum-Product Algorithm</a>&#8221;, IEEE Transactions on Information Theory 47:498-519, 2001.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (BpParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.arg">
<tt class="descname">arg</tt><big>(</big><em>(Bp)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (Bp)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.bound">
<tt class="descname">bound</tt><big>(</big><em>(Bp)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(Bp)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.infer">
<tt class="descname">infer</tt><big>(</big><em>(Bp)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.reset">
<tt class="descname">reset</tt><big>(</big><em>(Bp)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(Bp)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (Bp)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">BpParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1 [, (int)arg2 [, (float)arg3 [, (float)arg4]]]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.convergenceBound">
<tt class="descname">convergenceBound</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.convergenceBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Convergence bound stops message passing updates when message change is smaller than <tt class="docutils literal"><span class="pre">convergenceBound</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.damping">
<tt class="descname">damping</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Damping must be in [0,1]</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.isAcyclic">
<tt class="descname">isAcyclic</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.isAcyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>isAcyclic can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.maybe</span></tt> : if its unknown that the gm is acyclic (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.true</span></tt> : if its known that the gm is acyclic (gm has no loops)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.false</span></tt> : if its known that the gm is not acyclic (gm has loops)</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.set">
<tt class="descname">set</tt><big>(</big><em>(BpParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=100</em><span class="optional">[</span>, <em>(float)damping=0</em><span class="optional">[</span>, <em>(float)convergenceBound=0</em><span class="optional">[</span>, <em>(Tribool)isAcyclic=opengm.opengmcore._opengmcore.Tribool.maybe</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>steps: Number of message passing updates (default=100)</p>
<p>damping: Damp the message.</p>
<blockquote>
<div>Damping must be in [0,1] (default=0)</div></blockquote>
<p>convergenceBound: Convergence bound stops message passing updates when the difference</p>
<blockquote>
<div>between old and new messages is smaller than <tt class="docutils literal"><span class="pre">convergenceBound</span></tt> (default=0)</div></blockquote>
<p>isAcyclic: isAcyclic can be:</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.maybe</span></tt> : if its unknown that the gm is acyclic (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.true</span></tt> : if its known that the gm is acyclic / gm has no loops</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.false</span></tt> : if its known that the gm is not acyclic /gm has loops</p>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of message passing updates</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tree-reweighted-bp-trbp">
<h3><a class="toc-backref" href="#id47">Tree Reweighted Bp (TrBp)</a><a class="headerlink" href="#tree-reweighted-bp-trbp" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.TrBp">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">TrBp</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp" title="Permalink to this definition">¶</a></dt>
<dd><p>trbp docstring</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (TrBpParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.arg">
<tt class="descname">arg</tt><big>(</big><em>(TrBp)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (TrBp)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.bound">
<tt class="descname">bound</tt><big>(</big><em>(TrBp)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(TrBp)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.infer">
<tt class="descname">infer</tt><big>(</big><em>(TrBp)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.reset">
<tt class="descname">reset</tt><big>(</big><em>(TrBp)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(TrBp)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (TrBp)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">TrBpParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1 [, (int)arg2 [, (float)arg3 [, (float)arg4]]]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.convergenceBound">
<tt class="descname">convergenceBound</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.convergenceBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Convergence bound stops message passing updates when message change is smaller than <tt class="docutils literal"><span class="pre">convergenceBound</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.damping">
<tt class="descname">damping</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Damping must be in [0,1]</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.isAcyclic">
<tt class="descname">isAcyclic</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.isAcyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>isAcyclic can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.maybe</span></tt> : if its unknown that the gm is acyclic (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.true</span></tt> : if its known that the gm is acyclic (gm has no loops)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.false</span></tt> : if its known that the gm is not acyclic (gm has loops)</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.set">
<tt class="descname">set</tt><big>(</big><em>(TrBpParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=100</em><span class="optional">[</span>, <em>(float)damping=0</em><span class="optional">[</span>, <em>(float)convergenceBound=0</em><span class="optional">[</span>, <em>(Tribool)isAcyclic=opengm.opengmcore._opengmcore.Tribool.maybe</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>steps: Number of message passing updates (default=100)</p>
<p>damping: Damp the message.</p>
<blockquote>
<div>Damping must be in [0,1] (default=0)</div></blockquote>
<p>convergenceBound: Convergence bound stops message passing updates when the difference</p>
<blockquote>
<div>between old and new messages is smaller than <tt class="docutils literal"><span class="pre">convergenceBound</span></tt> (default=0)</div></blockquote>
<p>isAcyclic: isAcyclic can be:</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.maybe</span></tt> : if its unknown that the gm is acyclic (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.true</span></tt> : if its known that the gm is acyclic / gm has no loops</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.false</span></tt> : if its known that the gm is not acyclic /gm has loops</p>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of message passing updates</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="dynamic-programming">
<h3><a class="toc-backref" href="#id48">Dynamic Programming</a><a class="headerlink" href="#dynamic-programming" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">DynamicProgramming</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic Programming for tree shaped graphical models</p>
<p>limitations: gm must be a acyclic</p>
<p>guarantees: global optimal</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (DynamicProgrammingParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.arg">
<tt class="descname">arg</tt><big>(</big><em>(DynamicProgramming)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (DynamicProgramming)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.bound">
<tt class="descname">bound</tt><big>(</big><em>(DynamicProgramming)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(DynamicProgramming)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.infer">
<tt class="descname">infer</tt><big>(</big><em>(DynamicProgramming)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(DynamicProgramming)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (DynamicProgramming)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgrammingParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">DynamicProgrammingParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgrammingParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgrammingParameter.set">
<tt class="descname">set</tt><big>(</big><em>(DynamicProgrammingParameter)arg1</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgrammingParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>DynamicProgramming is parameter free but for convenience the <tt class="docutils literal"><span class="pre">set</span></tt> method is implemented.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id4">
<h3><a class="toc-backref" href="#id49">ICM</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.Icm">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">Icm</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterated Conditional Modes Algorithm (ICM):</p>
<p>cite: J. E. Besag: &#8220;<a class="reference external" href="http://webdocs.cs.ualberta.ca/~nray1/CMPUT617/Inference/Besag.pdf">On the Statistical Analysis of Dirty Pictures</a>&#8221;,Journal of the Royal Statistical Society, Series B 48(3):259-302, 1986.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (IcmParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.arg">
<tt class="descname">arg</tt><big>(</big><em>(Icm)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (Icm)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.bound">
<tt class="descname">bound</tt><big>(</big><em>(Icm)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(Icm)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.infer">
<tt class="descname">infer</tt><big>(</big><em>(Icm)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.reset">
<tt class="descname">reset</tt><big>(</big><em>(Icm)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(Icm)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (Icm)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.IcmParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">IcmParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.IcmParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1 [, (object)moveType]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.IcmParameter.moveType">
<tt class="descname">moveType</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.IcmParameter.moveType" title="Permalink to this definition">¶</a></dt>
<dd><p>moveType can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.IcmMoveType.variable</span></tt> :  move only one variable at once optimaly (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.IcmMoveType.factor</span></tt> :   move all variable of a factor at once optimaly</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.IcmParameter.set">
<tt class="descname">set</tt><big>(</big><em>(IcmParameter)arg1</em><span class="optional">[</span>, <em>(IcmMoveType)moveType=opengm.opengmcore._opengmcore.IcmMoveType.variable</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.IcmParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>moveType: moveType can be:</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.IcmMoveType.variable</span></tt> :  move only one variable at once optimaly (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.IcmMoveType.factor</span></tt> :   move all variable of a factor at once optimaly</p>
</div></blockquote>
<p>bound: AStar objective bound.</p>
<blockquote>
<div>A good bound will speedup inference (default = neutral value)</div></blockquote>
<p>maxHeapSize: Maximum size of the heap which is used while inference (default=3000000)</p>
<p>numberOfOpt: Select which n best states should be searched for while inference (default=1):</p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lazy-flipper-lf">
<h3><a class="toc-backref" href="#id50">Lazy Flipper (LF)</a><a class="headerlink" href="#lazy-flipper-lf" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">LazyFlipper</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper" title="Permalink to this definition">¶</a></dt>
<dd><p>Gibbs Sampler :</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: -</p>
<p>guarantees:optimal in a hamming distance of <tt class="docutils literal"><span class="pre">maxSubgraphSize</span></tt></p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (LazyFlipperParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.arg">
<tt class="descname">arg</tt><big>(</big><em>(LazyFlipper)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (LazyFlipper)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.bound">
<tt class="descname">bound</tt><big>(</big><em>(LazyFlipper)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(LazyFlipper)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.infer">
<tt class="descname">infer</tt><big>(</big><em>(LazyFlipper)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.reset">
<tt class="descname">reset</tt><big>(</big><em>(LazyFlipper)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(LazyFlipper)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (LazyFlipper)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipperParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">LazyFlipperParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipperParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1 [, (int)maxSubGraphSize]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipperParameter.maxSubgraphSize">
<tt class="descname">maxSubgraphSize</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipperParameter.maxSubgraphSize" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum subgraph size which is optimized</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipperParameter.set">
<tt class="descname">set</tt><big>(</big><em>(LazyFlipperParameter)arg1</em><span class="optional">[</span>, <em>(int)maxSubgraphSize=2</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipperParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div>maxSubgraphSize: maximum subgraph size which is optimized</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id5">
<h3><a class="toc-backref" href="#id51">LOC</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.LOC">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">LOC</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC" title="Permalink to this definition">¶</a></dt>
<dd><p>LOC:</p>
<p>cite: K. Jung, P. Kohli and D. Shah:&#8221;<a class="reference external" href="http://research.microsoft.com/en-us/um/people/pkohli/papers/jks_nips09_TR.pdf">Local Rules for Global MAP: When Do They Work?</a>&#8221;,NIPS 2009.</p>
<p>limitations: -</p>
<p>guarantees: epsilon approximation on planar graphs</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (LOCParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.arg">
<tt class="descname">arg</tt><big>(</big><em>(LOC)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (LOC)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.bound">
<tt class="descname">bound</tt><big>(</big><em>(LOC)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(LOC)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.infer">
<tt class="descname">infer</tt><big>(</big><em>(LOC)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.reset">
<tt class="descname">reset</tt><big>(</big><em>(LOC)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(LOC)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (LOC)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">LOCParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1, (float)arg2, (int)arg3, (int)arg4, (int)phi,maxRadius,maxIteration,aStarThreshold) -&gt; None</p>
<p>__init__( (object)arg1) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.aStarThreshold">
<tt class="descname">aStarThreshold</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.aStarThreshold" title="Permalink to this definition">¶</a></dt>
<dd><p>If there are more variables in the subgraph than <tt class="docutils literal"><span class="pre">aStarThreshold</span></tt> ,
AStar is used to optimise the subgraph, otherwise Bruteforce is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.maxRadius">
<tt class="descname">maxRadius</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.maxRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum subgraph radius.</p>
<p>The subgraph radius is in [0,maxRadius]</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.phi">
<tt class="descname">phi</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Open parameter in (truncated) geometric distribution.
The subgraph radius is sampled from that distribution</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.set">
<tt class="descname">set</tt><big>(</big><em>(LOCParameter)arg1</em><span class="optional">[</span>, <em>(float)phi=0.5</em><span class="optional">[</span>, <em>(int)maxRadius=5</em><span class="optional">[</span>, <em>(int)steps=0</em><span class="optional">[</span>, <em>(int)aStarThreshold=10</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>phi: Open parameter in (truncated) geometric distribution.</p>
<blockquote>
<div>The subgraph radius is sampled from that distribution(default=0.5)</div></blockquote>
<p>maxRadius: Maximum subgraph radius.</p>
<blockquote>
<div>The subgraph radius is in [0,maxRadius] (default=5)</div></blockquote>
<p>steps: Number of iterations.</p>
<blockquote>
<div>If steps is zero a suitable number is choosen. (default=0)</div></blockquote>
<p>aStarThreshold: If there are more variables in the subgraph than <tt class="docutils literal"><span class="pre">aStarThreshold</span></tt> ,</p>
<blockquote>
<div>AStar is used to optimise the subgraph, otherwise Bruteforce is used.</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations. 
If steps is zero a suitable number is choosen)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id52">Gibbs</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">Gibbs</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gibbs Sampler :</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (GibbsParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.arg">
<tt class="descname">arg</tt><big>(</big><em>(Gibbs)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (Gibbs)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.bound">
<tt class="descname">bound</tt><big>(</big><em>(Gibbs)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(Gibbs)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.infer">
<tt class="descname">infer</tt><big>(</big><em>(Gibbs)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.reset">
<tt class="descname">reset</tt><big>(</big><em>(Gibbs)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(Gibbs)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (Gibbs)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">GibbsParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter.burnInSteps">
<tt class="descname">burnInSteps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter.burnInSteps" title="Permalink to this definition">¶</a></dt>
<dd><p>do some sampling steps bevor the actual sampling</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter.set">
<tt class="descname">set</tt><big>(</big><em>(GibbsParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=100000.0</em><span class="optional">[</span>, <em>(int)burnInSteps=0</em><span class="optional">[</span>, <em>(GibbsVariableProposal)variableProposal=opengm.opengmcore._opengmcore.GibbsVariableProposal.random</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>steps: Number of sampling steps (default=100)</p>
<p>burnInSteps: do some sampling steps bevor the actual sampling (default=0)</p>
<p>variableProposal: variableProposal can be:</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.GibbsVariableProposal.random</span></tt> : The variable which is sampled is drawn randomly (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.GibbsVariableProposal.cyclic</span></tt> : All variables will be sampled in a permuted order.</p>
<blockquote>
<div>After all variables have been sampled the permutation is changed.</div></blockquote>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of sampling steps</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter.variableProposal">
<tt class="descname">variableProposal</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter.variableProposal" title="Permalink to this definition">¶</a></dt>
<dd><p>variableProposal can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.GibbsVariableProposal.random</span></tt> : The variable which is sampled is drawn randomly (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.GibbsVariableProposal.cyclic</span></tt> : All variables will be sampled in a permuted order.</p>
<blockquote>
<div>After all variables have been sampled the permutation is changed.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType">
<em class="property">class </em><tt class="descclassname">opengm.opengmcore._opengmcore.</tt><tt class="descname">IcmMoveType</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType.factor">
<tt class="descname">factor</tt><em class="property"> = opengm.opengmcore._opengmcore.IcmMoveType.factor</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType.factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType.names">
<tt class="descname">names</tt><em class="property"> = {'variable': opengm.opengmcore._opengmcore.IcmMoveType.variable, 'factor': opengm.opengmcore._opengmcore.IcmMoveType.factor}</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType.names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType.values">
<tt class="descname">values</tt><em class="property"> = {0: opengm.opengmcore._opengmcore.IcmMoveType.variable, 1: opengm.opengmcore._opengmcore.IcmMoveType.factor}</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType.variable">
<tt class="descname">variable</tt><em class="property"> = opengm.opengmcore._opengmcore.IcmMoveType.variable</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType.variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="grah-cut-gc">
<h3><a class="toc-backref" href="#id53">Grah Cut (GC)</a><a class="headerlink" href="#grah-cut-gc" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">GraphCutBoostKolmogorov</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphcut :</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (GraphCutBoostKolmogorovParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.arg">
<tt class="descname">arg</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (GraphCutBoostKolmogorov)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.bound">
<tt class="descname">bound</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.infer">
<tt class="descname">infer</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (GraphCutBoostKolmogorov)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">GraphCutBoostKolmogorovParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<p>__init__( (object)arg1, (float)arg2) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter.scale">
<tt class="descname">scale</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>rescale the objective function.(default=1)</p>
<p>This is only usefull if the min-st-cut uses</p>
<p>integral value types.</p>
<p>This will be supported in the next release.</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter.set">
<tt class="descname">set</tt><big>(</big><em>(GraphCutBoostKolmogorovParameter)arg1</em><span class="optional">[</span>, <em>(float)scale=10</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>scale: rescale the objective function.(default=1)</p>
<blockquote>
<div><p>This is only usefull if the min-st-cut uses</p>
<p>integral value types.</p>
<p>This will be supported in the next release.</p>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id9">
<h3><a class="toc-backref" href="#id54">Alpha-Beta Swap</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AlphaBetaSwapBoostKolmogorov</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha Beta Swap:</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: TODO</p>
<p>guarantees:  TODO</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (AlphaBetaSwapBoostKolmogorovParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.arg">
<tt class="descname">arg</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (AlphaBetaSwapBoostKolmogorov)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.bound">
<tt class="descname">bound</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.infer">
<tt class="descname">infer</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (AlphaBetaSwapBoostKolmogorov)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AlphaBetaSwapBoostKolmogorovParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter.set">
<tt class="descname">set</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorovParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=1000</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div>steps: Maximum number of iterations (default=1000)</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>steps: Maximum number of iterations</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="id11">
<h3><a class="toc-backref" href="#id55">Alpha-Expansion</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AlphaExpansionBoostKolmogorov</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha Expansion :</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (AlphaExpansionBoostKolmogorovParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.arg">
<tt class="descname">arg</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (AlphaExpansionBoostKolmogorov)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.bound">
<tt class="descname">bound</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.infer">
<tt class="descname">infer</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (AlphaExpansionBoostKolmogorov)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AlphaExpansionBoostKolmogorovParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<p>__init__( (object)arg1, (int)arg2 [, (GraphCutBoostKolmogorovParameter)arg3]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.graphCutParameter">
<tt class="descname">graphCutParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.graphCutParameter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.set">
<tt class="descname">set</tt><big>(</big><em>(AlphaExpansionBoostKolmogorovParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=1000</em><span class="optional">[</span>, <em>(GraphCutBoostKolmogorovParameter)graphCutParameter=&lt;opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter object at 0xa8be95c&gt;</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>steps: Maximum number of iterations (default=1000)</p>
<p>graphCutParameter: parameter of the graphcut used within inference (graphCutParameter())</p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="bruteforce">
<h3><a class="toc-backref" href="#id56">Bruteforce</a><a class="headerlink" href="#bruteforce" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">Bruteforce</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Bruteforce:</p>
<p>limitations: gm must be small enough</p>
<p>guarantees: global optimal</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (BruteforceParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.arg">
<tt class="descname">arg</tt><big>(</big><em>(Bruteforce)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (Bruteforce)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.bound">
<tt class="descname">bound</tt><big>(</big><em>(Bruteforce)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(Bruteforce)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.infer">
<tt class="descname">infer</tt><big>(</big><em>(Bruteforce)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.reset">
<tt class="descname">reset</tt><big>(</big><em>(Bruteforce)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(Bruteforce)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (Bruteforce)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.BruteforceParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">BruteforceParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BruteforceParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.BruteforceParameter.set">
<tt class="descname">set</tt><big>(</big><em>(BruteforceParameter)arg1</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BruteforceParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Bruteforce is parameter free but for convenience the <tt class="docutils literal"><span class="pre">set</span></tt> method is implemented.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>limitations: gm must be small enough</p>
<p>guarantees:  global optimal</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">OpenGM Python Tutorial</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#import-opengm">Import Opengm</a></li>
<li><a class="reference internal" href="#construct-a-graphical-model">Construct a Graphical Model</a><ul>
<li><a class="reference internal" href="#add-functions-to-a-graphical-model">Add Functions to a Graphical Model</a></li>
<li><a class="reference internal" href="#add-factors-and-functions-to-a-graphical-model">Add Factors and Functions to a Graphical Model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#save-and-load-a-graphical-model">Save and Load a Graphical Model</a></li>
<li><a class="reference internal" href="#infer-optimize-a-graphical-model">Infer/Optimize a Graphical Model</a><ul>
<li><a class="reference internal" href="#belief-propagation-bp">Belief propagation (Bp)</a></li>
<li><a class="reference internal" href="#treereweighted-belief-propagation-trbp">Treereweighted Belief propagation (Trbp)</a></li>
<li><a class="reference internal" href="#icm">ICM</a></li>
<li><a class="reference internal" href="#gibbs">Gibbs</a></li>
<li><a class="reference internal" href="#astar">AStar</a></li>
<li><a class="reference internal" href="#loc">LOC</a></li>
<li><a class="reference internal" href="#lazy-flipper">Lazy Flipper</a></li>
<li><a class="reference internal" href="#graph-cut">Graph Cut</a></li>
<li><a class="reference internal" href="#alpha-beta-swap">Alpha Beta Swap</a></li>
<li><a class="reference internal" href="#alpha-expansion">Alpha Expansion</a></li>
<li><a class="reference internal" href="#cplex">CPlex</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#opengm-python-examples">OpenGM Python Examples</a><ul>
<li><a class="reference internal" href="#potts-model">Potts Model</a></li>
<li><a class="reference internal" href="#markov-chain">Markov Chain</a></li>
<li><a class="reference internal" href="#interpixel-boundary-segmentation">Interpixel Boundary Segmentation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#opengm-python-snippets">OpenGM Python Snippets</a><ul>
<li><a class="reference internal" href="#inspect-a-graphical-model">Inspect a Graphical Model</a></li>
<li><a class="reference internal" href="#iterate-over-a-factors-values">Iterate over a Factors Values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#opengm-python-reference-documentation">OpenGM Python Reference Documentation</a><ul>
<li><a class="reference internal" href="#id1">opengm</a><ul>
<li><a class="reference internal" href="#graphicalmodel">GraphicalModel</a></li>
<li><a class="reference internal" href="#factor">Factor</a></li>
<li><a class="reference internal" href="#independentfactor">IndependentFactor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#opengm-inference">opengm.inference</a><ul>
<li><a class="reference internal" href="#id2">AStar</a></li>
<li><a class="reference internal" href="#id3">Belief Propagation (Bp)</a></li>
<li><a class="reference internal" href="#tree-reweighted-bp-trbp">Tree Reweighted Bp (TrBp)</a></li>
<li><a class="reference internal" href="#dynamic-programming">Dynamic Programming</a></li>
<li><a class="reference internal" href="#id4">ICM</a></li>
<li><a class="reference internal" href="#lazy-flipper-lf">Lazy Flipper (LF)</a></li>
<li><a class="reference internal" href="#id5">LOC</a></li>
<li><a class="reference internal" href="#id6">Gibbs</a></li>
<li><a class="reference internal" href="#grah-cut-gc">Grah Cut (GC)</a></li>
<li><a class="reference internal" href="#id9">Alpha-Beta Swap</a></li>
<li><a class="reference internal" href="#id11">Alpha-Expansion</a></li>
<li><a class="reference internal" href="#bruteforce">Bruteforce</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="#">vigranumpy beta0.91 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Thorsten Beier.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>