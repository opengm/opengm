

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>opengm &mdash; vigranumpy beta0.91 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     'beta0.91',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="vigranumpy beta0.91 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">vigranumpy beta0.91 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="opengm">
<h1>opengm<a class="headerlink" href="#opengm" title="Permalink to this headline">¶</a></h1>
<div class="section" id="graphicalmodel">
<h2>GraphicalModel<a class="headerlink" href="#graphicalmodel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="opengm.graphicalModel">
<tt class="descclassname">opengm.</tt><tt class="descname">graphicalModel</tt><big>(</big><em>numberOfLabels</em>, <em>operator='adder'</em><big>)</big><a class="headerlink" href="#opengm.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<p>The namespace <tt class="docutils literal"><span class="pre">opengm.opengmcore._opengmcore.adder</span></tt> is reachable via <tt class="docutils literal"><span class="pre">opengm.adder</span></tt>.
In the reference documentation of the graphical model only <tt class="docutils literal"><span class="pre">opengm.adder</span></tt> is considered,
since the documentation of <tt class="docutils literal"><span class="pre">opengm.multiplier</span></tt> ( <tt class="docutils literal"><span class="pre">opengm.opengmcore._opengmcore.multiplier</span></tt>) would be
exactly the same.</p>
<dl class="class">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel">
<em class="property">class </em><tt class="descclassname">opengm.opengmcore._opengmcore.adder.</tt><tt class="descname">GraphicalModel</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>The central class of opengm which holds the factor graph and functions of the graphical model</p>
<dl class="docutils">
<dt>__init__( (object)arg1) -&gt; None :</dt>
<dd>Construct an empty graphical model with no variables</dd>
<dt>__init__( (object)arg1, (object)numberOfLabels) -&gt; object :</dt>
<dd><p class="first">Construct a gm from a numpy array which holds the number of labels for all variables.</p>
<blockquote>
<div>The gm will have as many variables as the length of the numpy array</div></blockquote>
<p>Args:</p>
<blockquote class="last">
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
</dd>
<dt>__init__( (object)arg1, (list)numberOfLabels) -&gt; object :</dt>
<dd><p class="first">Construct a gm from a python list which holds the number of labels for all variables.</p>
<p>The gm will have as many variables as the length of the list
Args:</p>
<blockquote class="last">
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
</dd>
</dl>
<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(int)factorIndex</em><big>)</big> &rarr; Factor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a factor of the graphical model</p>
<p>Args:</p>
<blockquote>
<div><p>factorIndex: index of a factor w.r.t. the gm</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">factorIndex</span></tt> has to be a integral scalar:</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A const reference to the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt>.</dd>
<dt>Example:</dt>
<dd>factor=gm[someFactorIndex]</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.__init__">
<tt class="descname">__init__</tt><big>(</big><em>(object)arg1</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Construct an empty graphical model with no variables</div></blockquote>
<dl class="docutils">
<dt>__init__( (object)arg1, (object)numberOfLabels) -&gt; object :</dt>
<dd><p class="first">Construct a gm from a numpy array which holds the number of labels for all variables.</p>
<blockquote>
<div>The gm will have as many variables as the length of the numpy array</div></blockquote>
<p>Args:</p>
<blockquote class="last">
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
</dd>
<dt>__init__( (object)arg1, (list)numberOfLabels) -&gt; object :</dt>
<dd><p class="first">Construct a gm from a python list which holds the number of labels for all variables.</p>
<p>The gm will have as many variables as the length of the list
Args:</p>
<blockquote class="last">
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.__str__">
<tt class="descname">__str__</tt><big>(</big><em>(GraphicalModel)arg1</em><big>)</big> &rarr; str :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.__str__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Print a a gm as stringReturns:</dt>
<dd>A string which describes the graphical model</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.addFactor">
<tt class="descname">addFactor</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(FunctionIdentifier)fid</em>, <em>(object)variableIndices</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.addFactor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Adds a factor to the gm.</p>
<blockquote>
<div><p>The factors will is connected to the function indicated with &#8220;fid&#8221;.</p>
<p>The factors variables are given by <tt class="docutils literal"><span class="pre">variableIndices</span></tt>. &#8220;variableIndices&#8221; has to be sorted.</p>
<p>In this overloading of &#8220;addFactor&#8221; the type of &#8220;variableIndices&#8221;  has to be a 1d numpy array</p>
</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>variableIndices: the factors variables</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">variableIndices</span></tt> has to be sorted.</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>index of the added factor .</dd>
<dt>Example</dt>
<dd><p class="first">adding a factor to the graphical model:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="c"># assuming there is a function &quot;f&quot;</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">vis</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
<span class="c">#vis has to be sorted </span>
<span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">vis</span><span class="p">)</span>    
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>addFactor( (GraphicalModel)arg1, (FunctionIdentifier)fid, (tuple)variableIndices) -&gt; long :</dt>
<dd><p class="first">Adds a factor to the gm.</p>
<blockquote>
<div><p>The factors will is connected to the function indicated with &#8220;fid&#8221;.</p>
<p>The factors variables are given by <tt class="docutils literal"><span class="pre">variableIndices</span></tt>. &#8220;variableIndices&#8221; has to be sorted.</p>
<p>In this overloading of &#8220;addFactor&#8221; the type of &#8220;variableIndices&#8221;  has to be a tuple</p>
</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>variableIndices: the factors variables</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">variableIndices</span></tt> has to be sorted.</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>Returns:</dt>
<dd>index of the added factor .</dd>
<dt>Example:</dt>
<dd><p class="first">adding a factor to the graphical model:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="c"># assuming there is a function &quot;f&quot;</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">vis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
<span class="c">#vis has to be sorted </span>
<span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">vis</span><span class="p">)</span>    
</pre></div>
</div>
</dd>
</dl>
</dd>
<dt>addFactor( (GraphicalModel)arg1, (FunctionIdentifier)fid, (list)variableIndices) -&gt; long :</dt>
<dd><p class="first">Adds a factor to the gm.</p>
<blockquote>
<div><p>The factors will is connected to the function indicated with &#8220;fid&#8221;.</p>
<p>The factors variables are given by <tt class="docutils literal"><span class="pre">variableIndices</span></tt>. &#8220;variableIndices&#8221; has to be sorted.</p>
<p>In this overloading of &#8220;addFactor&#8221; the type of &#8220;variableIndices&#8221;  has to be a list</p>
</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>variableIndices: the factors variables</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">variableIndices</span></tt> has to be sorted.</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>Returns:</dt>
<dd>index of the added factor .</dd>
<dt>Example:</dt>
<dd><p class="first">adding a factor to the graphical model:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="c"># assuming there is a function &quot;f&quot;</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">vis</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="c">#vis has to be sorted </span>
<span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span><span class="n">vis</span><span class="p">)</span>    
</pre></div>
</div>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.addFunction">
<tt class="descname">addFunction</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(object)function</em><big>)</big> &rarr; FunctionIdentifier :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.addFunction" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a function to the graphical model.Args:</p>
<blockquote>
<div><p>function: a function/ value table</p>
<blockquote>
<div>The type of &#8220;function&#8221;  has to be a numpy ndarray.</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">A function identifier (fid) .</p>
<blockquote class="last">
<div>This fid is used to connect a factor to this function</div></blockquote>
</dd>
<dt>Examples:</dt>
<dd><p class="first">Adding 1th-order function with the shape [3]:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">1.4</span><span class="p">,</span><span class="mf">0.1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Adding 2th-order function with  the shape [4,4]:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="c">#fill the function with values</span>
<span class="c">#..........</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Adding 3th-order function with the shape [4,5,2]:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">f</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="c">#fill the function with values</span>
<span class="c">#..........</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.assign">
<tt class="descname">assign</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(object)numberOfLabels</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.assign" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Assign a gm from a python list which holds the number of labels for all variables.</p>
<blockquote>
<div>The gm will have as many variables as the length of the numpy array</div></blockquote>
<p>Args:</p>
<blockquote>
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>assign( (GraphicalModel)arg1, (list)numberOfLabels) -&gt; None :</dt>
<dd><p class="first">Assign a gm from a python list which holds the number of labels for all variables.</p>
<blockquote>
<div>The gm will have as many variables as the length of the list</div></blockquote>
<p>Args:</p>
<blockquote>
<div>numberOfLabels: holds the number of labels for each variable</div></blockquote>
<dl class="last docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.evaluate">
<tt class="descname">evaluate</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(object)labels</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Evaluates the factors of given a labelSequence.</p>
<blockquote>
<div>In this overloading the type of  &#8220;labelSequence&#8221; has to be a 1d numpy array</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>labelSequence: A labeling for all variables.</p>
<blockquote>
<div>Has to as long as <tt class="docutils literal"><span class="pre">gm.numberOfVariables</span></tt>.</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The energy / probability for the given <tt class="docutils literal"><span class="pre">labelSequence</span></tt></dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>evaluate( (GraphicalModel)arg1, (list)labels) -&gt; float :</dt>
<dd><p class="first">Evaluates the factors of given a labelSequence.</p>
<blockquote>
<div>In this overloading the type of  &#8220;labelSequence&#8221; has to be a list</div></blockquote>
<p>Args:</p>
<blockquote>
<div><p>labelSequence: A labeling for all variables.</p>
<blockquote>
<div>Has to as long as <tt class="docutils literal"><span class="pre">gm.numberOfVariables</span></tt>.</div></blockquote>
</div></blockquote>
<dl class="last docutils">
<dt>Returns:</dt>
<dd>The energy / probability for the given <tt class="docutils literal"><span class="pre">labelSequence</span></tt></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.factorOfVariable">
<tt class="descname">factorOfVariable</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)variableIndex</em>, <em>(long)factorIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.factorOfVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variable index of a varible which is connected to a factor.</p>
<p>Args:</p>
<blockquote>
<div><p>factorIndex: index of a variable w.r.t the gm</p>
<p>variableIndex: index of a factor w.r.t the variable at <tt class="docutils literal"><span class="pre">variableInex</span></tt></p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The variableIndex w.r.t. the gm of the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.isAcyclic">
<tt class="descname">isAcyclic</tt><big>(</big><em>(GraphicalModel)arg1</em><big>)</big> &rarr; bool :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.isAcyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>check if the graphical is isAcyclic.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">True if model has no loops / is acyclic</p>
<p class="last">False if model has loops / is not acyclic</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfFactors">
<tt class="descname">numberOfFactors</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfFactors" title="Permalink to this definition">¶</a></dt>
<dd><p>The Number of factors of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfFactorsOfVariable">
<tt class="descname">numberOfFactorsOfVariable</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)variableIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfFactorsOfVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of factors which are connected to a variable</p>
<p>Args:</p>
<blockquote>
<div>variableIndex: index of a variable w.r.t. the gm</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">The nubmer of variables which are connected</p>
<blockquote class="last">
<div>to the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfLabels">
<tt class="descname">numberOfLabels</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)variableIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of labels for a variable</p>
<p>Args:</p>
<blockquote>
<div>variableIndex: index to a variable in this gm</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The nubmer of labels for the variable at <tt class="docutils literal"><span class="pre">variableIndex</span></tt></dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfVariables">
<tt class="descname">numberOfVariables</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of variables of the graphical modelReturns:
Number of variables.</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfVariablesOfFactor">
<tt class="descname">numberOfVariablesOfFactor</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)factorIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.numberOfVariablesOfFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of variables which are connected to a factor</p>
<p>Args:</p>
<blockquote>
<div>factorIndex: index to a factor in this gm</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><p class="first">The nubmer of variables which are connected</p>
<blockquote class="last">
<div>to the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.operator">
<tt class="descname">operator</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.operator" title="Permalink to this definition">¶</a></dt>
<dd><p>The operator of the graphical model as a string</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.space">
<tt class="descname">space</tt><big>(</big><em>(GraphicalModel)arg1</em><big>)</big> &rarr; Space :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.space" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variable space of the graphical model</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A const reference to space of the gm.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.GraphicalModel.variableOfFactor">
<tt class="descname">variableOfFactor</tt><big>(</big><em>(GraphicalModel)arg1</em>, <em>(long)factorIndex</em>, <em>(long)variableIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.GraphicalModel.variableOfFactor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variable index of a varible which is connected to a factor.</p>
<p>Args:</p>
<blockquote>
<div><p>factorIndex: index of a factor w.r.t the gm</p>
<p>variableIndex: index of a variable w.r.t the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>The variableIndex w.r.t. the gm of the factor at <tt class="docutils literal"><span class="pre">factorIndex</span></tt></dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="factor">
<h2>Factor<a class="headerlink" href="#factor" title="Permalink to this headline">¶</a></h2>
<p>The namespace <tt class="docutils literal"><span class="pre">opengm.opengmcore._opengmcore.adder</span></tt> is reachable via <tt class="docutils literal"><span class="pre">opengm.adder</span></tt>.
In the reference documentation of the factor model only <tt class="docutils literal"><span class="pre">opengm.adder</span></tt> is considered,
since the documentation of <tt class="docutils literal"><span class="pre">opengm.multiplier</span></tt> ( <tt class="docutils literal"><span class="pre">opengm.opengmcore._opengmcore.multiplier</span></tt>) would be
exactly the same.</p>
<dl class="class">
<dt id="opengm.opengmcore._opengmcore.adder.Factor">
<em class="property">class </em><tt class="descclassname">opengm.opengmcore._opengmcore.adder.</tt><tt class="descname">Factor</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__add__">
<tt class="descname">__add__</tt><big>(</big><em>(Factor)arg1</em>, <em>(Factor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>__add__( (Factor)arg1, (float)arg2) -&gt; object</p>
<p>__add__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__div__">
<tt class="descname">__div__</tt><big>(</big><em>(Factor)arg1</em>, <em>(Factor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__div__" title="Permalink to this definition">¶</a></dt>
<dd><p>__div__( (Factor)arg1, (float)arg2) -&gt; object</p>
<p>__div__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Access the factors value table for a given label sequence.In this overloading the type of the label sequence has to be a 1d numpy ndarray:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">TODO</span>  
</pre></div>
</div>
</div></blockquote>
<p>__getitem__( (Factor)arg1, (tuple)arg2) -&gt; float</p>
<p>__getitem__( (Factor)arg1, (list)arg2) -&gt; float</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__instance_size__">
<tt class="descname">__instance_size__</tt><em class="property"> = 36</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__instance_size__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'opengm.opengmcore'</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__mul__">
<tt class="descname">__mul__</tt><big>(</big><em>(Factor)arg1</em>, <em>(Factor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__mul__( (Factor)arg1, (float)arg2) -&gt; object</p>
<p>__mul__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__radd__">
<tt class="descname">__radd__</tt><big>(</big><em>(Factor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__radd__" title="Permalink to this definition">¶</a></dt>
<dd><p>__radd__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__rdiv__">
<tt class="descname">__rdiv__</tt><big>(</big><em>(Factor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__rdiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rdiv__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__reduce__">
<tt class="descname">__reduce__</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__rmul__">
<tt class="descname">__rmul__</tt><big>(</big><em>(Factor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rmul__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__rsub__">
<tt class="descname">__rsub__</tt><big>(</big><em>(Factor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rsub__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__str__">
<tt class="descname">__str__</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; str<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__str__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.__sub__">
<tt class="descname">__sub__</tt><big>(</big><em>(Factor)arg1</em>, <em>(Factor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__sub__( (Factor)arg1, (float)arg2) -&gt; object</p>
<p>__sub__( (Factor)arg1, (IndependentFactor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.asIndependentFactor">
<tt class="descname">asIndependentFactor</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; IndependentFactor<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.asIndependentFactor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.asNumpy">
<tt class="descname">asNumpy</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.asNumpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.copyValues">
<tt class="descname">copyValues</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.copyValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the value table of a factor to a new allocated 1d-numpy array in last-coordinate-major-order</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.copyValuesSwitchedOrder">
<tt class="descname">copyValuesSwitchedOrder</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.copyValuesSwitchedOrder" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the value table of a factor to a new allocated 1d-numpy array in first-coordinate-major-order</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.functionIndex">
<tt class="descname">functionIndex</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.functionIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the function index of a factor, which indicated the index of the function this factor is connected to</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.functionType">
<tt class="descname">functionType</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.functionType" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the function type index of a factorm which indicated the type of the function this factor is connected to</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isAbsoluteDifference">
<tt class="descname">isAbsoluteDifference</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isAbsoluteDifference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isGeneralizedPotts">
<tt class="descname">isGeneralizedPotts</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isGeneralizedPotts" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the factors value table can be written as generalized Potts function</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isPotts">
<tt class="descname">isPotts</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isPotts" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the factors value table can be written as Potts function</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isSquaredDifference">
<tt class="descname">isSquaredDifference</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isSquaredDifference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isSubmodular">
<tt class="descname">isSubmodular</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isSubmodular" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the factor is submodular</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isTruncatedAbsoluteDifference">
<tt class="descname">isTruncatedAbsoluteDifference</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isTruncatedAbsoluteDifference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.isTruncatedSquaredDifference">
<tt class="descname">isTruncatedSquaredDifference</tt><big>(</big><em>(Factor)arg1</em><big>)</big> &rarr; bool<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.isTruncatedSquaredDifference" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.max">
<tt class="descname">max</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)accVariables</em><big>)</big> &rarr; IndependentFactor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.max" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a 1d numpy.ndarray</div></blockquote>
<dl class="docutils">
<dt>max( (Factor)arg1, (tuple)accVariables) -&gt; IndependentFactor :</dt>
<dd>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a tuple</dd>
<dt>max( (Factor)arg1, (list)accVariables) -&gt; IndependentFactor :</dt>
<dd>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt>. 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a list</dd>
<dt>max( (Factor)arg1) -&gt; float :</dt>
<dd>Get the maximum value of the factor ( the maximum scalar in the factors value table)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.min">
<tt class="descname">min</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)accVariables</em><big>)</big> &rarr; IndependentFactor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.min" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a 1d numpy.ndarray</div></blockquote>
<dl class="docutils">
<dt>min( (Factor)arg1, (tuple)accVariables) -&gt; IndependentFactor :</dt>
<dd>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a tuple</dd>
<dt>min( (Factor)arg1, (list)accVariables) -&gt; IndependentFactor :</dt>
<dd>Minimize / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt>. 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a list</dd>
<dt>min( (Factor)arg1) -&gt; float :</dt>
<dd>Get the minimum value of the factor ( the minimum scalar in the factors value table)</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.numberOfLabels">
<tt class="descname">numberOfLabels</tt><big>(</big><em>(Factor)arg1</em>, <em>(long)variableIndex</em><big>)</big> &rarr; long :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.numberOfLabels" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of labels for a variable of the
factor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="p">)</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span> <span class="p">)</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span> <span class="p">)</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfLabels</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">5</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.numberOfVariables">
<tt class="descname">numberOfVariables</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.numberOfVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of variables which are connected to the
factor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#assuming gm,fid2 and fid3 exist:</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid2</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfVariables</span><span class="o">==</span><span class="mi">2</span> <span class="p">)</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid3</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">numberOfVariables</span><span class="o">==</span><span class="mi">3</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.product">
<tt class="descname">product</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)accVariables</em><big>)</big> &rarr; IndependentFactor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.product" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Multiply / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a 1d numpy.ndarray</div></blockquote>
<dl class="docutils">
<dt>product( (Factor)arg1, (tuple)accVariables) -&gt; IndependentFactor :</dt>
<dd>Multiply / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a tuple</dd>
<dt>product( (Factor)arg1, (list)accVariables) -&gt; IndependentFactor :</dt>
<dd>Multiply / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt>. 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a list</dd>
<dt>product( (Factor)arg1) -&gt; float :</dt>
<dd>Get the product of all values of the factor</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of a factor, which is a sequence of the number of lables for all variables which are connected to this factor</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.size">
<tt class="descname">size</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of entries in the factor&#8217;s value
table:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">gm</span><span class="o">=</span><span class="n">opengm</span><span class="o">.</span><span class="n">graphicalModel</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">4</span> <span class="p">)</span>
<span class="n">fid</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFunction</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">))</span>
<span class="n">factorIndex</span><span class="o">=</span><span class="n">gm</span><span class="o">.</span><span class="n">addFactor</span><span class="p">(</span><span class="n">fid</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="k">assert</span><span class="p">(</span> <span class="n">gm</span><span class="p">[</span><span class="n">factorIndex</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">8</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.sum">
<tt class="descname">sum</tt><big>(</big><em>(Factor)arg1</em>, <em>(object)accVariables</em><big>)</big> &rarr; IndependentFactor :<a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.sum" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Integrate / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a 1d numpy.ndarray</div></blockquote>
<dl class="docutils">
<dt>sum( (Factor)arg1, (tuple)accVariables) -&gt; IndependentFactor :</dt>
<dd>Integrate / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt> 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a tuple</dd>
<dt>sum( (Factor)arg1, (list)accVariables) -&gt; IndependentFactor :</dt>
<dd>Integrate / accumulate over some variables by of the factor.These variables are given by <tt class="docutils literal"><span class="pre">accVariables</span></tt>. 
The result is an independentFactor. This independentFactor is only connected to the factors variables which where not in <tt class="docutils literal"><span class="pre">accVariables</span></tt>.
In this overloading the type of <tt class="docutils literal"><span class="pre">accVariables</span></tt> has to be a list</dd>
<dt>sum( (Factor)arg1) -&gt; float :</dt>
<dd>Get the sum of all values of the factor</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.adder.Factor.variableIndices">
<tt class="descname">variableIndices</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.adder.Factor.variableIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the variable indices of a factor (the indices of all variables which are connected to this factor)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="independentfactor">
<h2>IndependentFactor<a class="headerlink" href="#independentfactor" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor">
<em class="property">class </em><tt class="descclassname">opengm.opengmcore._opengmcore.</tt><tt class="descname">IndependentFactor</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.PyIndependentFactor">
<tt class="descname">PyIndependentFactor</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.PyIndependentFactor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__add__">
<tt class="descname">__add__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>__add__( (IndependentFactor)arg1, (float)arg2) -&gt; object</p>
<p>__add__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__add__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__div__">
<tt class="descname">__div__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__div__" title="Permalink to this definition">¶</a></dt>
<dd><p>__div__( (IndependentFactor)arg1, (float)arg2) -&gt; object</p>
<p>__div__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__div__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(tuple)arg2</em><big>)</big> &rarr; float<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>__getitem__( (IndependentFactor)arg1, (list)arg2) -&gt; float</p>
<p>__getitem__( (IndependentFactor)arg1, (object)arg2) -&gt; float</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__iadd__">
<tt class="descname">__iadd__</tt><big>(</big><em>(object)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__iadd__" title="Permalink to this definition">¶</a></dt>
<dd><p>__iadd__( (object)arg1, (float)arg2) -&gt; object</p>
<p>__iadd__( (object)arg1, (Factor)arg2) -&gt; object</p>
<p>__iadd__( (object)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__idiv__">
<tt class="descname">__idiv__</tt><big>(</big><em>(object)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__idiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>__idiv__( (object)arg1, (float)arg2) -&gt; object</p>
<p>__idiv__( (object)arg1, (Factor)arg2) -&gt; object</p>
<p>__idiv__( (object)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__imul__">
<tt class="descname">__imul__</tt><big>(</big><em>(object)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__imul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__imul__( (object)arg1, (float)arg2) -&gt; object</p>
<p>__imul__( (object)arg1, (Factor)arg2) -&gt; object</p>
<p>__imul__( (object)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__instance_size__">
<tt class="descname">__instance_size__</tt><em class="property"> = 60</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__instance_size__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__isub__">
<tt class="descname">__isub__</tt><big>(</big><em>(object)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__isub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__isub__( (object)arg1, (float)arg2) -&gt; object</p>
<p>__isub__( (object)arg1, (Factor)arg2) -&gt; object</p>
<p>__isub__( (object)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__module__">
<tt class="descname">__module__</tt><em class="property"> = 'opengm.opengmcore'</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__module__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__mul__">
<tt class="descname">__mul__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__mul__( (IndependentFactor)arg1, (float)arg2) -&gt; object</p>
<p>__mul__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__mul__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__radd__">
<tt class="descname">__radd__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__radd__" title="Permalink to this definition">¶</a></dt>
<dd><p>__radd__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__radd__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__rdiv__">
<tt class="descname">__rdiv__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__rdiv__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rdiv__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__rdiv__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__reduce__">
<tt class="descname">__reduce__</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__reduce__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__rmul__">
<tt class="descname">__rmul__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rmul__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__rmul__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__rsub__">
<tt class="descname">__rsub__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(float)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__rsub__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__rsub__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__str__">
<tt class="descname">__str__</tt><big>(</big><em>(IndependentFactor)arg1</em><big>)</big> &rarr; str<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__str__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.__sub__">
<tt class="descname">__sub__</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(IndependentFactor)arg2</em><big>)</big> &rarr; object<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>__sub__( (IndependentFactor)arg1, (float)arg2) -&gt; object</p>
<p>__sub__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
<p>__sub__( (IndependentFactor)arg1, (Factor)arg2) -&gt; object</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.asNumpy">
<tt class="descname">asNumpy</tt><big>(</big><big>)</big><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.asNumpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.copyValuesSwitchedOrder">
<tt class="descname">copyValuesSwitchedOrder</tt><big>(</big><em>(IndependentFactor)arg1</em><big>)</big> &rarr; numpy.ndarray<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.copyValuesSwitchedOrder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.min">
<tt class="descname">min</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; IndependentFactor<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.min" title="Permalink to this definition">¶</a></dt>
<dd><p>min( (IndependentFactor)arg1, (tuple)arg2) -&gt; IndependentFactor</p>
<p>min( (IndependentFactor)arg1, (list)arg2) -&gt; IndependentFactor</p>
<p>min( (IndependentFactor)arg1) -&gt; float</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.minInplace">
<tt class="descname">minInplace</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(object)arg2</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.minInplace" title="Permalink to this definition">¶</a></dt>
<dd><p>minInplace( (IndependentFactor)arg1, (tuple)arg2) -&gt; None</p>
<p>minInplace( (IndependentFactor)arg1, (list)arg2) -&gt; None</p>
</dd></dl>

<dl class="method">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.numberOfLabels">
<tt class="descname">numberOfLabels</tt><big>(</big><em>(IndependentFactor)arg1</em>, <em>(long)arg2</em><big>)</big> &rarr; long<a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.numberOfLabels" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.numberOfVariables">
<tt class="descname">numberOfVariables</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.numberOfVariables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IndependentFactor.shape">
<tt class="descname">shape</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IndependentFactor.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the shape of a independent factor, 
which is a sequence of the number of lables for all variables which are connected to this factor</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="opengm-inference">
<h1>opengm.inference<a class="headerlink" href="#opengm-inference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="astar">
<h2>AStar<a class="headerlink" href="#astar" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AStar">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AStar</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar" title="Permalink to this definition">¶</a></dt>
<dd><p>A star search algorithm:</p>
<p>cite: Kappes, J. H. :&#8221;Inference on Highly-Connected Discrete Graphical Models with Applications to Visual Object Recognition &#8221;,Ph.D. Thesis 2011.</p>
<p>Bergtholdt, M. &amp; Kappes, J. H. &amp; Schnoerr, C.:&#8221;<a class="reference external" href="http://hci.iwr.uni-heidelberg.de/Staff/jkappes/publications/dagm2006.pdf">Learning of Graphical Models and Efficient Inference for Object Class Recognition</a>&#8221;,  DAGM 2006</p>
<p>Bergtholdt, M. &amp; Kappes, J. H. &amp; Schmidt, S. &amp; Schnoerr, C.: &#8220;<a class="reference external" href="https://www.inf.tu-dresden.de/content/institutes/ki/is/HS_SS09_Papers/A_Study_of_Parts_Based_Object_Class_Detection_Using_Complete_Graphs.pdf">A Study of Parts-Based Object Class Detection Using Complete Graphs</a>&#8221;,  DAGM 2006</p>
<p>limitations: graph must be small enough</p>
<p>guarantees: global optimal</p>
<p>The AStar-Algo transform the problem into a shortest path problem in an exponentially large graph.
Due to the problem structure, this graph can be represented implicitly!
To find the shortest path we perform a best first search and use a admissable tree-based heuristic
to underestimate the cost to a goal node.
This lower bound allows us to reduce the search to an manageable 
subspace of the exponentially large search-space.</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (AStarParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.arg">
<tt class="descname">arg</tt><big>(</big><em>(AStar)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (AStar)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.bound">
<tt class="descname">bound</tt><big>(</big><em>(AStar)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(AStar)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.infer">
<tt class="descname">infer</tt><big>(</big><em>(AStar)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.reset">
<tt class="descname">reset</tt><big>(</big><em>(AStar)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStar.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(AStar)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStar.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (AStar)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AStarParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.heuristic">
<tt class="descname">heuristic</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>heuristic can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.default</span></tt> :default AStar heuristc (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.standart</span></tt> : standart AStar heuristic</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.fast</span></tt> : fast AStar heuristic for second order gm&#8217;s</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.maxHeapSize">
<tt class="descname">maxHeapSize</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.maxHeapSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum size of the heap which is used while inference</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.numberOfOpt">
<tt class="descname">numberOfOpt</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.numberOfOpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Select which n best states should be searched for while inference:</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.obectiveBound">
<tt class="descname">obectiveBound</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.obectiveBound" title="Permalink to this definition">¶</a></dt>
<dd><p>AStar objective bound.</p>
<p>A good bound will speedup inference</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AStarParameter.set">
<tt class="descname">set</tt><big>(</big><em>(AStarParameter)arg1</em><span class="optional">[</span>, <em>(AStarHeuristic)heuristic=opengm.opengmcore._opengmcore.AStarHeuristic.default</em><span class="optional">[</span>, <em>(float)bound=inf</em><span class="optional">[</span>, <em>(int)maxHeapSize=3000000</em><span class="optional">[</span>, <em>(int)numberOfOpt=1</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AStarParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>heuristic: Number of message passing updates</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.default</span></tt> :default AStar heuristc (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.standart</span></tt> : stanart AStar heuristic</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.AStarHeuristic.fast</span></tt> : fast AStar heuristic for second order gm&#8217;s</p>
</div></blockquote>
<p>bound: AStar objective bound.</p>
<blockquote>
<div>A good bound will speedup inference (default = neutral value)</div></blockquote>
<p>maxHeapSize: Maximum size of the heap which is used while inference (default=3000000)</p>
<p>numberOfOpt: Select which n best states should be searched for while inference (default=1):</p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="belief-propagation-bp">
<h2>Belief Propagation (Bp)<a class="headerlink" href="#belief-propagation-bp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.Bp">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">Bp</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp" title="Permalink to this definition">¶</a></dt>
<dd><p>Belief Propagation (Bp):</p>
<p>cite: Cf. F. R. Kschischang, B. J. Frey and H.-A. Loeliger:&#8221;<a class="reference external" href="http://www.cs.utoronto.ca/~radford/csc2506/factor.pdf">Factor Graphs and the Sum-Product Algorithm</a>&#8221;, IEEE Transactions on Information Theory 47:498-519, 2001.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (BpParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.arg">
<tt class="descname">arg</tt><big>(</big><em>(Bp)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (Bp)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.bound">
<tt class="descname">bound</tt><big>(</big><em>(Bp)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(Bp)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.infer">
<tt class="descname">infer</tt><big>(</big><em>(Bp)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.reset">
<tt class="descname">reset</tt><big>(</big><em>(Bp)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bp.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(Bp)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bp.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (Bp)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">BpParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1 [, (int)arg2 [, (float)arg3 [, (float)arg4]]]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.convergenceBound">
<tt class="descname">convergenceBound</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.convergenceBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Convergence bound stops message passing updates when message change is smaller than <tt class="docutils literal"><span class="pre">convergenceBound</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.damping">
<tt class="descname">damping</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Damping must be in [0,1]</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.isAcyclic">
<tt class="descname">isAcyclic</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.isAcyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>isAcyclic can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.maybe</span></tt> : if its unknown that the gm is acyclic (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.true</span></tt> : if its known that the gm is acyclic (gm has no loops)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.false</span></tt> : if its known that the gm is not acyclic (gm has loops)</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.set">
<tt class="descname">set</tt><big>(</big><em>(BpParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=100</em><span class="optional">[</span>, <em>(float)damping=0</em><span class="optional">[</span>, <em>(float)convergenceBound=0</em><span class="optional">[</span>, <em>(Tribool)isAcyclic=opengm.opengmcore._opengmcore.Tribool.maybe</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>steps: Number of message passing updates (default=100)</p>
<p>damping: Damp the message.</p>
<blockquote>
<div>Damping must be in [0,1] (default=0)</div></blockquote>
<p>convergenceBound: Convergence bound stops message passing updates when the difference</p>
<blockquote>
<div>between old and new messages is smaller than <tt class="docutils literal"><span class="pre">convergenceBound</span></tt> (default=0)</div></blockquote>
<p>isAcyclic: isAcyclic can be:</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.maybe</span></tt> : if its unknown that the gm is acyclic (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.true</span></tt> : if its known that the gm is acyclic / gm has no loops</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.false</span></tt> : if its known that the gm is not acyclic /gm has loops</p>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.BpParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BpParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of message passing updates</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tree-reweighted-bp-trbp">
<h2>Tree Reweighted Bp (TrBp)<a class="headerlink" href="#tree-reweighted-bp-trbp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.TrBp">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">TrBp</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp" title="Permalink to this definition">¶</a></dt>
<dd><p>trbp docstring</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (TrBpParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.arg">
<tt class="descname">arg</tt><big>(</big><em>(TrBp)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (TrBp)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.bound">
<tt class="descname">bound</tt><big>(</big><em>(TrBp)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(TrBp)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.infer">
<tt class="descname">infer</tt><big>(</big><em>(TrBp)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.reset">
<tt class="descname">reset</tt><big>(</big><em>(TrBp)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBp.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(TrBp)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBp.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (TrBp)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">TrBpParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1 [, (int)arg2 [, (float)arg3 [, (float)arg4]]]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.convergenceBound">
<tt class="descname">convergenceBound</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.convergenceBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Convergence bound stops message passing updates when message change is smaller than <tt class="docutils literal"><span class="pre">convergenceBound</span></tt></p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.damping">
<tt class="descname">damping</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Damping must be in [0,1]</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.isAcyclic">
<tt class="descname">isAcyclic</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.isAcyclic" title="Permalink to this definition">¶</a></dt>
<dd><p>isAcyclic can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.maybe</span></tt> : if its unknown that the gm is acyclic (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.true</span></tt> : if its known that the gm is acyclic (gm has no loops)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.false</span></tt> : if its known that the gm is not acyclic (gm has loops)</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.set">
<tt class="descname">set</tt><big>(</big><em>(TrBpParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=100</em><span class="optional">[</span>, <em>(float)damping=0</em><span class="optional">[</span>, <em>(float)convergenceBound=0</em><span class="optional">[</span>, <em>(Tribool)isAcyclic=opengm.opengmcore._opengmcore.Tribool.maybe</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>steps: Number of message passing updates (default=100)</p>
<p>damping: Damp the message.</p>
<blockquote>
<div>Damping must be in [0,1] (default=0)</div></blockquote>
<p>convergenceBound: Convergence bound stops message passing updates when the difference</p>
<blockquote>
<div>between old and new messages is smaller than <tt class="docutils literal"><span class="pre">convergenceBound</span></tt> (default=0)</div></blockquote>
<p>isAcyclic: isAcyclic can be:</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.maybe</span></tt> : if its unknown that the gm is acyclic (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.true</span></tt> : if its known that the gm is acyclic / gm has no loops</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.Tribool.false</span></tt> : if its known that the gm is not acyclic /gm has loops</p>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.TrBpParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.TrBpParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of message passing updates</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="dynamic-programming">
<h2>Dynamic Programming<a class="headerlink" href="#dynamic-programming" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">DynamicProgramming</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming" title="Permalink to this definition">¶</a></dt>
<dd><p>Dynamic Programming for tree shaped graphical models</p>
<p>limitations: gm must be a acyclic</p>
<p>guarantees: global optimal</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (DynamicProgrammingParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.arg">
<tt class="descname">arg</tt><big>(</big><em>(DynamicProgramming)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (DynamicProgramming)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.bound">
<tt class="descname">bound</tt><big>(</big><em>(DynamicProgramming)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(DynamicProgramming)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.infer">
<tt class="descname">infer</tt><big>(</big><em>(DynamicProgramming)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgramming.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(DynamicProgramming)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgramming.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (DynamicProgramming)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgrammingParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">DynamicProgrammingParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgrammingParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.DynamicProgrammingParameter.set">
<tt class="descname">set</tt><big>(</big><em>(DynamicProgrammingParameter)arg1</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.DynamicProgrammingParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>DynamicProgramming is parameter free but for convenience the <tt class="docutils literal"><span class="pre">set</span></tt> method is implemented.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="icm">
<h2>ICM<a class="headerlink" href="#icm" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.Icm">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">Icm</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterated Conditional Modes Algorithm (ICM):</p>
<p>cite: J. E. Besag: &#8220;<a class="reference external" href="http://webdocs.cs.ualberta.ca/~nray1/CMPUT617/Inference/Besag.pdf">On the Statistical Analysis of Dirty Pictures</a>&#8221;,Journal of the Royal Statistical Society, Series B 48(3):259-302, 1986.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (IcmParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.arg">
<tt class="descname">arg</tt><big>(</big><em>(Icm)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (Icm)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.bound">
<tt class="descname">bound</tt><big>(</big><em>(Icm)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(Icm)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.infer">
<tt class="descname">infer</tt><big>(</big><em>(Icm)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.reset">
<tt class="descname">reset</tt><big>(</big><em>(Icm)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Icm.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(Icm)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Icm.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (Icm)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.IcmParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">IcmParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.IcmParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1 [, (object)moveType]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.IcmParameter.moveType">
<tt class="descname">moveType</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.IcmParameter.moveType" title="Permalink to this definition">¶</a></dt>
<dd><p>moveType can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.IcmMoveType.variable</span></tt> :  move only one variable at once optimaly (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.IcmMoveType.factor</span></tt> :   move all variable of a factor at once optimaly</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.IcmParameter.set">
<tt class="descname">set</tt><big>(</big><em>(IcmParameter)arg1</em><span class="optional">[</span>, <em>(IcmMoveType)moveType=opengm.opengmcore._opengmcore.IcmMoveType.variable</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.IcmParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>moveType: moveType can be:</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.IcmMoveType.variable</span></tt> :  move only one variable at once optimaly (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.IcmMoveType.factor</span></tt> :   move all variable of a factor at once optimaly</p>
</div></blockquote>
<p>bound: AStar objective bound.</p>
<blockquote>
<div>A good bound will speedup inference (default = neutral value)</div></blockquote>
<p>maxHeapSize: Maximum size of the heap which is used while inference (default=3000000)</p>
<p>numberOfOpt: Select which n best states should be searched for while inference (default=1):</p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lazy-flipper-lf">
<h2>Lazy Flipper (LF)<a class="headerlink" href="#lazy-flipper-lf" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">LazyFlipper</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper" title="Permalink to this definition">¶</a></dt>
<dd><p>Gibbs Sampler :</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: -</p>
<p>guarantees:optimal in a hamming distance of <tt class="docutils literal"><span class="pre">maxSubgraphSize</span></tt></p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (LazyFlipperParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.arg">
<tt class="descname">arg</tt><big>(</big><em>(LazyFlipper)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (LazyFlipper)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.bound">
<tt class="descname">bound</tt><big>(</big><em>(LazyFlipper)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(LazyFlipper)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.infer">
<tt class="descname">infer</tt><big>(</big><em>(LazyFlipper)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.reset">
<tt class="descname">reset</tt><big>(</big><em>(LazyFlipper)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipper.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(LazyFlipper)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipper.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (LazyFlipper)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipperParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">LazyFlipperParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipperParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1 [, (int)maxSubGraphSize]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipperParameter.maxSubgraphSize">
<tt class="descname">maxSubgraphSize</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipperParameter.maxSubgraphSize" title="Permalink to this definition">¶</a></dt>
<dd><p>maximum subgraph size which is optimized</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LazyFlipperParameter.set">
<tt class="descname">set</tt><big>(</big><em>(LazyFlipperParameter)arg1</em><span class="optional">[</span>, <em>(int)maxSubgraphSize=2</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LazyFlipperParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div>maxSubgraphSize: maximum subgraph size which is optimized</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="loc">
<h2>LOC<a class="headerlink" href="#loc" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.LOC">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">LOC</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC" title="Permalink to this definition">¶</a></dt>
<dd><p>LOC:</p>
<p>cite: K. Jung, P. Kohli and D. Shah:&#8221;<a class="reference external" href="http://research.microsoft.com/en-us/um/people/pkohli/papers/jks_nips09_TR.pdf">Local Rules for Global MAP: When Do They Work?</a>&#8221;,NIPS 2009.</p>
<p>limitations: -</p>
<p>guarantees: epsilon approximation on planar graphs</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (LOCParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.arg">
<tt class="descname">arg</tt><big>(</big><em>(LOC)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (LOC)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.bound">
<tt class="descname">bound</tt><big>(</big><em>(LOC)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(LOC)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.infer">
<tt class="descname">infer</tt><big>(</big><em>(LOC)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.reset">
<tt class="descname">reset</tt><big>(</big><em>(LOC)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOC.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(LOC)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOC.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (LOC)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">LOCParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1, (float)arg2, (int)arg3, (int)arg4, (int)phi,maxRadius,maxIteration,aStarThreshold) -&gt; None</p>
<p>__init__( (object)arg1) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.aStarThreshold">
<tt class="descname">aStarThreshold</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.aStarThreshold" title="Permalink to this definition">¶</a></dt>
<dd><p>If there are more variables in the subgraph than <tt class="docutils literal"><span class="pre">aStarThreshold</span></tt> ,
AStar is used to optimise the subgraph, otherwise Bruteforce is used.</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.maxRadius">
<tt class="descname">maxRadius</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.maxRadius" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum subgraph radius.</p>
<p>The subgraph radius is in [0,maxRadius]</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.phi">
<tt class="descname">phi</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Open parameter in (truncated) geometric distribution.
The subgraph radius is sampled from that distribution</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.set">
<tt class="descname">set</tt><big>(</big><em>(LOCParameter)arg1</em><span class="optional">[</span>, <em>(float)phi=0.5</em><span class="optional">[</span>, <em>(int)maxRadius=5</em><span class="optional">[</span>, <em>(int)steps=0</em><span class="optional">[</span>, <em>(int)aStarThreshold=10</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>phi: Open parameter in (truncated) geometric distribution.</p>
<blockquote>
<div>The subgraph radius is sampled from that distribution(default=0.5)</div></blockquote>
<p>maxRadius: Maximum subgraph radius.</p>
<blockquote>
<div>The subgraph radius is in [0,maxRadius] (default=5)</div></blockquote>
<p>steps: Number of iterations.</p>
<blockquote>
<div>If steps is zero a suitable number is choosen. (default=0)</div></blockquote>
<p>aStarThreshold: If there are more variables in the subgraph than <tt class="docutils literal"><span class="pre">aStarThreshold</span></tt> ,</p>
<blockquote>
<div>AStar is used to optimise the subgraph, otherwise Bruteforce is used.</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.LOCParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.LOCParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations. 
If steps is zero a suitable number is choosen)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="gibbs">
<h2>Gibbs<a class="headerlink" href="#gibbs" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">Gibbs</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Gibbs Sampler :</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (GibbsParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.arg">
<tt class="descname">arg</tt><big>(</big><em>(Gibbs)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (Gibbs)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.bound">
<tt class="descname">bound</tt><big>(</big><em>(Gibbs)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(Gibbs)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.infer">
<tt class="descname">infer</tt><big>(</big><em>(Gibbs)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.reset">
<tt class="descname">reset</tt><big>(</big><em>(Gibbs)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Gibbs.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(Gibbs)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Gibbs.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (Gibbs)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">GibbsParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter.burnInSteps">
<tt class="descname">burnInSteps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter.burnInSteps" title="Permalink to this definition">¶</a></dt>
<dd><p>do some sampling steps bevor the actual sampling</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter.set">
<tt class="descname">set</tt><big>(</big><em>(GibbsParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=100000.0</em><span class="optional">[</span>, <em>(int)burnInSteps=0</em><span class="optional">[</span>, <em>(GibbsVariableProposal)variableProposal=opengm.opengmcore._opengmcore.GibbsVariableProposal.random</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>steps: Number of sampling steps (default=100)</p>
<p>burnInSteps: do some sampling steps bevor the actual sampling (default=0)</p>
<p>variableProposal: variableProposal can be:</p>
<blockquote>
<div><p>-<tt class="docutils literal"><span class="pre">opengm.GibbsVariableProposal.random</span></tt> : The variable which is sampled is drawn randomly (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.GibbsVariableProposal.cyclic</span></tt> : All variables will be sampled in a permuted order.</p>
<blockquote>
<div>After all variables have been sampled the permutation is changed.</div></blockquote>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of sampling steps</p>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.GibbsParameter.variableProposal">
<tt class="descname">variableProposal</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GibbsParameter.variableProposal" title="Permalink to this definition">¶</a></dt>
<dd><p>variableProposal can be:</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.GibbsVariableProposal.random</span></tt> : The variable which is sampled is drawn randomly (default)</p>
<p>-<tt class="docutils literal"><span class="pre">opengm.GibbsVariableProposal.cyclic</span></tt> : All variables will be sampled in a permuted order.</p>
<blockquote>
<div>After all variables have been sampled the permutation is changed.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType">
<em class="property">class </em><tt class="descclassname">opengm.opengmcore._opengmcore.</tt><tt class="descname">IcmMoveType</tt><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType.factor">
<tt class="descname">factor</tt><em class="property"> = opengm.opengmcore._opengmcore.IcmMoveType.factor</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType.factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType.names">
<tt class="descname">names</tt><em class="property"> = {'variable': opengm.opengmcore._opengmcore.IcmMoveType.variable, 'factor': opengm.opengmcore._opengmcore.IcmMoveType.factor}</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType.names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType.values">
<tt class="descname">values</tt><em class="property"> = {0: opengm.opengmcore._opengmcore.IcmMoveType.variable, 1: opengm.opengmcore._opengmcore.IcmMoveType.factor}</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType.values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="opengm.opengmcore._opengmcore.IcmMoveType.variable">
<tt class="descname">variable</tt><em class="property"> = opengm.opengmcore._opengmcore.IcmMoveType.variable</em><a class="headerlink" href="#opengm.opengmcore._opengmcore.IcmMoveType.variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="grah-cut-gc">
<h2>Grah Cut (GC)<a class="headerlink" href="#grah-cut-gc" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">GraphCutBoostKolmogorov</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov" title="Permalink to this definition">¶</a></dt>
<dd><p>Graphcut :</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (GraphCutBoostKolmogorovParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.arg">
<tt class="descname">arg</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (GraphCutBoostKolmogorov)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.bound">
<tt class="descname">bound</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.infer">
<tt class="descname">infer</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(GraphCutBoostKolmogorov)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorov.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (GraphCutBoostKolmogorov)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">GraphCutBoostKolmogorovParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<p>__init__( (object)arg1, (float)arg2) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter.scale">
<tt class="descname">scale</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>rescale the objective function.(default=1)</p>
<p>This is only usefull if the min-st-cut uses</p>
<p>integral value types.</p>
<p>This will be supported in the next release.</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter.set">
<tt class="descname">set</tt><big>(</big><em>(GraphCutBoostKolmogorovParameter)arg1</em><span class="optional">[</span>, <em>(float)scale=10</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>scale: rescale the objective function.(default=1)</p>
<blockquote>
<div><p>This is only usefull if the min-st-cut uses</p>
<p>integral value types.</p>
<p>This will be supported in the next release.</p>
</div></blockquote>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="alpha-beta-swap">
<h2>Alpha-Beta Swap<a class="headerlink" href="#alpha-beta-swap" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AlphaBetaSwapBoostKolmogorov</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha Beta Swap:</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: TODO</p>
<p>guarantees:  TODO</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (AlphaBetaSwapBoostKolmogorovParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.arg">
<tt class="descname">arg</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (AlphaBetaSwapBoostKolmogorov)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.bound">
<tt class="descname">bound</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.infer">
<tt class="descname">infer</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorov)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorov.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (AlphaBetaSwapBoostKolmogorov)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AlphaBetaSwapBoostKolmogorovParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter.set">
<tt class="descname">set</tt><big>(</big><em>(AlphaBetaSwapBoostKolmogorovParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=1000</em><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div>steps: Maximum number of iterations (default=1000)</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaBetaSwapBoostKolmogorovParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd><p>steps: Maximum number of iterations</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="alpha-expansion">
<h2>Alpha-Expansion<a class="headerlink" href="#alpha-expansion" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AlphaExpansionBoostKolmogorov</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov" title="Permalink to this definition">¶</a></dt>
<dd><p>Alpha Expansion :</p>
<p>cite: ???: &#8220;<a class="reference external" href="paper_url">title</a>&#8221;,Journal.</p>
<p>limitations: -</p>
<p>guarantees: -</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (AlphaExpansionBoostKolmogorovParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.arg">
<tt class="descname">arg</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (AlphaExpansionBoostKolmogorov)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.bound">
<tt class="descname">bound</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.infer">
<tt class="descname">infer</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(AlphaExpansionBoostKolmogorov)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorov.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (AlphaExpansionBoostKolmogorov)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">AlphaExpansionBoostKolmogorovParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<p>__init__( (object)arg1, (int)arg2 [, (GraphCutBoostKolmogorovParameter)arg3]) -&gt; None</p>
<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.graphCutParameter">
<tt class="descname">graphCutParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.graphCutParameter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.set">
<tt class="descname">set</tt><big>(</big><em>(AlphaExpansionBoostKolmogorovParameter)arg1</em><span class="optional">[</span>, <em>(int)steps=1000</em><span class="optional">[</span>, <em>(GraphCutBoostKolmogorovParameter)graphCutParameter=&lt;opengm.inference._inference.adder.minimizer.GraphCutBoostKolmogorovParameter object at 0xa8be95c&gt;</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters values.</p>
<p>All values of the parameter have a default value.</p>
<p>Args:</p>
<blockquote>
<div><p>steps: Maximum number of iterations (default=1000)</p>
<p>graphCutParameter: parameter of the graphcut used within inference (graphCutParameter())</p>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.steps">
<tt class="descname">steps</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.AlphaExpansionBoostKolmogorovParameter.steps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="bruteforce">
<h2>Bruteforce<a class="headerlink" href="#bruteforce" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">Bruteforce</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce" title="Permalink to this definition">¶</a></dt>
<dd><p>Bruteforce:</p>
<p>limitations: gm must be small enough</p>
<p>guarantees: global optimal</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2) -&gt; None</p>
<p>__init__( (object)arg1, (GraphicalModel)arg2, (BruteforceParameter)arg3) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.arg">
<tt class="descname">arg</tt><big>(</big><em>(Bruteforce)arg1</em><big>)</big> &rarr; numpy.ndarray :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.arg" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></div></blockquote>
<dl class="docutils">
<dt>arg( (Bruteforce)arg1, (int)arg2) -&gt; numpy.ndarray :</dt>
<dd>get the inference result <tt class="docutils literal"><span class="pre">.infer</span></tt> has to be called bevore <tt class="docutils literal"><span class="pre">arg</span></tt></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.bound">
<tt class="descname">bound</tt><big>(</big><em>(Bruteforce)arg1</em><big>)</big> &rarr; float :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.bound" title="Permalink to this definition">¶</a></dt>
<dd><p>get the current bound</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.graphicalModel">
<tt class="descname">graphicalModel</tt><big>(</big><em>(Bruteforce)arg1</em><big>)</big> &rarr; GraphicalModel :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.graphicalModel" title="Permalink to this definition">¶</a></dt>
<dd><p>get a const reference of the graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.infer">
<tt class="descname">infer</tt><big>(</big><em>(Bruteforce)arg1</em><span class="optional">[</span>, <em>(bool)verbose=False</em><span class="optional">[</span>, <em>(int)printNth=1</em><span class="optional">[</span>, <em>(bool)multiline=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; InferenceTermination :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.infer" title="Permalink to this definition">¶</a></dt>
<dd><p>infer a graphical model</p>
</dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.reset">
<tt class="descname">reset</tt><big>(</big><em>(Bruteforce)arg1</em><big>)</big> &rarr; None<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.Bruteforce.setStartingPoint">
<tt class="descname">setStartingPoint</tt><big>(</big><em>(Bruteforce)arg1</em>, <em>(object)startingPoint</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.Bruteforce.setStartingPoint" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</div></blockquote>
<dl class="docutils">
<dt>setStartingPoint( (Bruteforce)arg1, (list)startingPoint) -&gt; None :</dt>
<dd>Set a starting labeling as start point for inference. Warm started inference might lead to better results.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="opengm.inference._inference.adder.minimizer.BruteforceParameter">
<em class="property">class </em><tt class="descclassname">opengm.inference._inference.adder.minimizer.</tt><tt class="descname">BruteforceParameter</tt><a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BruteforceParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>__init__( (object)arg1) -&gt; None</p>
<dl class="method">
<dt id="opengm.inference._inference.adder.minimizer.BruteforceParameter.set">
<tt class="descname">set</tt><big>(</big><em>(BruteforceParameter)arg1</em><big>)</big> &rarr; None :<a class="headerlink" href="#opengm.inference._inference.adder.minimizer.BruteforceParameter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Bruteforce is parameter free but for convenience the <tt class="docutils literal"><span class="pre">set</span></tt> method is implemented.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>None</dd>
</dl>
<p>limitations: gm must be small enough</p>
<p>guarantees:  global optimal</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">opengm</a><ul>
<li><a class="reference internal" href="#graphicalmodel">GraphicalModel</a></li>
<li><a class="reference internal" href="#factor">Factor</a></li>
<li><a class="reference internal" href="#independentfactor">IndependentFactor</a></li>
</ul>
</li>
<li><a class="reference internal" href="#opengm-inference">opengm.inference</a><ul>
<li><a class="reference internal" href="#astar">AStar</a></li>
<li><a class="reference internal" href="#belief-propagation-bp">Belief Propagation (Bp)</a></li>
<li><a class="reference internal" href="#tree-reweighted-bp-trbp">Tree Reweighted Bp (TrBp)</a></li>
<li><a class="reference internal" href="#dynamic-programming">Dynamic Programming</a></li>
<li><a class="reference internal" href="#icm">ICM</a></li>
<li><a class="reference internal" href="#lazy-flipper-lf">Lazy Flipper (LF)</a></li>
<li><a class="reference internal" href="#loc">LOC</a></li>
<li><a class="reference internal" href="#gibbs">Gibbs</a></li>
<li><a class="reference internal" href="#grah-cut-gc">Grah Cut (GC)</a></li>
<li><a class="reference internal" href="#alpha-beta-swap">Alpha-Beta Swap</a></li>
<li><a class="reference internal" href="#alpha-expansion">Alpha-Expansion</a></li>
<li><a class="reference internal" href="#bruteforce">Bruteforce</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/refdocu.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">vigranumpy beta0.91 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Thorsten Beier.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>